class E{static IMPORT="import";static FROM="from";static LET="let";static OPEN="open";static CLASS="class";static INTERFACE="interface";static EXTENDS="extends";static IMPLEMENTS="implements";static CONSTRUCTOR="constructor";static NEW="new";static THIS="this";static PUBLIC="public";static PRIVATE="private";static STATIC="static";static READONLY="readonly";static RETURN="return";static SUPER="super";static TRUE="true";static FALSE="false";static IF="if";static ELSE="else";static MATCH="match";static DEFAULT="default";static FOREACH="foreach";static IN="in";static NULL="null";static VDOM="vdom";static BRACKET_SQUARE_OPEN="[";static BRACKET_SQUARE_CLOSE="]";static BRACE_OPEN="{";static BRACE_CLOSE="}";static PARENTHESES_OPEN="(";static PARENTHESES_CLOSE=")";static SEMICOLON=";";static COLON=":";static COMMA=",";static ARROW="->";static DOT=".";static ASSIGN="=";static PLUS="+";static MINUS="-";static DIVIDE="/";static MULTIPLY="*";static MODULUS="%";static EXCLAMATION_MARK="!";static QUESTION_MARK="?";static LESS_THAN="<";static GREATER_THAN=">";static LESS_EQUAL="<=";static GREATER_EQUAL=">=";static EQUAL="==";static NOT_EQUAL="!=";static AND="&&";static OR="||";static XML_CLOSE_TAG="/>";static XML_OPEN_CLOSE_TAG="</";static KEYWORDS=[E.IMPORT,E.FROM,E.OPEN,E.CLASS,E.INTERFACE,E.EXTENDS,E.IMPLEMENTS,E.PUBLIC,E.PRIVATE,E.STATIC,E.READONLY,E.RETURN,E.LET,E.NEW,E.THIS,E.IF,E.ELSE,E.MATCH,E.DEFAULT,E.FOREACH,E.IN,E.NULL,E.VDOM];static ARITHMETIC=[E.PLUS,E.MINUS,E.DIVIDE,E.MULTIPLY,E.MODULUS];static COMPARISON=[E.LESS_THAN,E.GREATER_THAN,E.LESS_EQUAL,E.GREATER_EQUAL];static EQUALITY=[E.EQUAL,E.NOT_EQUAL];static LOGICAL=[E.AND,E.OR];static OPERATORS=[E.EXCLAMATION_MARK,E.QUESTION_MARK,E.ARROW,E.DOT,E.ASSIGN,E.PLUS,E.MINUS,E.DIVIDE,E.MULTIPLY,E.MODULUS,E.LESS_THAN,E.GREATER_THAN,E.LESS_EQUAL,E.GREATER_EQUAL,E.EQUAL,E.NOT_EQUAL,E.AND,E.OR];static MATH_OPERATORS=[E.PLUS,E.MINUS,E.DIVIDE,E.MULTIPLY,E.MODULUS];static LOGIC_OPERATORS=[E.LESS_THAN,E.GREATER_THAN,E.LESS_EQUAL,E.GREATER_EQUAL,E.EQUAL,E.NOT_EQUAL,E.AND,E.OR];static PUNCTUATIONS=[E.BRACKET_SQUARE_OPEN,E.BRACKET_SQUARE_CLOSE,E.BRACE_OPEN,E.BRACE_CLOSE,E.PARENTHESES_OPEN,E.PARENTHESES_CLOSE,E.SEMICOLON,E.COLON,E.COMMA];static DOM_OPERATORS=[E.ARROW,E.DOT,E.ASSIGN,E.LESS_THAN,E.GREATER_THAN,E.XML_OPEN_CLOSE_TAG,E.XML_CLOSE_TAG];static DOM_PUNCTUATIONS=[E.BRACKET_SQUARE_OPEN,E.BRACKET_SQUARE_CLOSE,E.BRACE_OPEN,E.BRACE_CLOSE,E.PARENTHESES_OPEN,E.PARENTHESES_CLOSE,E.SEMICOLON,E.COLON,E.COMMA]}class K{static MIXED="mixed";static VOID="void";static NUMBER="number";static STRING="string";static BOOLEAN="boolean";static ARRAY="array";static NULL="null"}class i{static KEYWORDS=new Set(E.KEYWORDS);static OPERATORS=new Set(E.OPERATORS);static PUNCTUATIONS=new Set(E.PUNCTUATIONS);static DOM_OPERATORS=new Set(E.DOM_OPERATORS);static DOM_PUNCTUATIONS=new Set(E.DOM_PUNCTUATIONS);static COMMENT_LINE="//";isAlpha(O){return/[a-z_]/i.test(O)}isNumeric(O){return/[0-9]/.test(O)}isAlphaNumeric(O){return this.isAlpha(O)||this.isNumeric(O)}isWhitespace(O){return/\s/.test(O)}}class Z{static COMMENT="comment";static ANNOTATION="annotation";static IDENTIFIER="identifier";static KEYWORD="keyword";static PUNCTUATION="punctuation";static NUMBER="number";static STRING="string";static BOOLEAN="boolean";static OPERATOR="operator";static TEXT="text";static EOF="eof"}class M{type;value;line=1;column=1;start;end;source;constructor(O,I,U,_,L){this.type=O,this.value=I,this.start=U,this.end=_,this.source=L}withLineAndColumn(O,I){return this.line=O,this.column=I,this}}class z{static PROGRAMM="program";static INDEX="index";static IDENTIFIER="identifier";static ANNOTATION="annotation";static PARAMETER="parameter";static IMPORT=E.IMPORT;static NUMBER=K.NUMBER;static STRING=K.STRING;static BOOLEAN=K.BOOLEAN;static NULL=K.NULL;static NEW=E.NEW;static CLASS=E.CLASS;static INTERFACE=E.INTERFACE;static CONSTRUCTOR=E.CONSTRUCTOR;static THIS=E.THIS;static RETURN=E.RETURN;static VDOM="vdom_declaration";static VDOM_TEXT="vdom_text_declaration";static UNARY="unary_expression";static LAMBDA="lambda_expression";static ARRAY="array_declaration";static TYPE="type_declaration";static FIELD="field_declaration";static MEMBER="member_expression";static METHOD="method_declaration";static CALL="call_expression";static VARIABLE="variable_declaration";static EXPRESSION="expression_statement";static BINARY="binary_expression";static ASSIGNMENT="assignment_expression";static IF="if_statement";static THEN="then_statement";static ELSE="else_statement";static MATCH="match_statement";static MATCH_CASE="match_case_statement";static FOREACH="foreach_statement"}class q{isExpression=!1;name="";span=null;type;value=null;children;constructor(O,I=[]){this.type=O,this.children=I}}class p extends q{callee;arguments;constructor(O,I=[]){super(z.CALL);this.callee=O,this.arguments=I,this.isExpression=!0}}class o extends q{arguments;typeAnnotation;constructor(O,I){super(z.NEW);this.arguments=O,this.typeAnnotation=I,this.name=I.name,this.isExpression=!0}}class BO extends q{left;right;operator;constructor(O,I,U){super(z.BINARY);this.left=O,this.right=I,this.operator=U,this.isExpression=!0}}class TO extends q{left;right;constructor(O,I){super(z.ASSIGNMENT);this.left=O,this.right=I,this.isExpression=!0}}class S extends q{object;property;constructor(O,I){super(z.MEMBER);this.object=O,this.property=I,this.isExpression=!0}}class JO extends q{operator;argument;constructor(O,I){super(z.UNARY);this.operator=O,this.argument=I,this.isExpression=!0}}class fO extends q{object;index;constructor(O,I){super(z.INDEX);this.object=O,this.index=I,this.isExpression=!0}}class m extends q{elements=[];constructor(){super(z.ARRAY);this.isExpression=!0}}class l extends q{parameters;returnType;constructor(O,I,U){super(z.LAMBDA,U);this.parameters=O,this.returnType=I,this.isExpression=!0}}class s extends q{modifiers;fieldType;init=null;constructor(O,I,U,_=null){super(z.FIELD);this.name=O,this.modifiers=I,this.fieldType=U,this.init=_}}class ZO extends q{typeAnnotation=null;init=null;constructor(O,I=null,U=null){super(z.VARIABLE);this.name=O,this.typeAnnotation=I,this.init=U}}class qO extends q{expr;constructor(O){super(z.EXPRESSION);this.expr=O}}class r extends q{argument;constructor(O=null){super(z.RETURN);this.argument=O}}class v extends q{annotations;modifiers;typeParameters;superClass;implementsInterfaces;constructor(O,I,U,_,L,W=null,$=[]){super(z.CLASS,$);this.name=O,this.annotations=I,this.modifiers=U,this.typeParameters=_,this.superClass=W,this.implementsInterfaces=L}}class KO extends q{annotations;modifiers;typeParameters;extendsInterfaces;constructor(O,I,U,_,L,W=[]){super(z.INTERFACE,W);this.name=O,this.annotations=I,this.modifiers=U,this.typeParameters=_,this.extendsInterfaces=L}}class VI extends q{properties=new Map;constructor(O){super(z.ANNOTATION);this.name=O}}class PO extends q{typeAnnotation;defaultValue;constructor(O,I,U=null){super(z.PARAMETER);this.typeAnnotation=I,this.name=O,this.defaultValue=U}}class T extends q{annotations;modifiers;typeParameters;parameters;returnType;constructor(O,I,U,_,L,W,$=null,H=[]){super(I,H);this.name=O,this.annotations=U,this.modifiers=_,this.typeParameters=L,this.parameters=W,this.returnType=$}}class YO extends q{names;from;constructor(O,I=null){super(z.IMPORT);this.names=O,this.from=I}}class GI extends q{constructor(O=[]){super(z.THEN,O)}}class VO extends q{condition;then;else=null;constructor(O,I){super(z.IF);this.condition=O,this.then=I}}class hI extends q{constructor(O=[]){super(z.ELSE,O)}}class AO extends q{expression;cases;defaultCase=null;constructor(O,I,U=null){super(z.MATCH);this.expression=O,this.cases=I,this.defaultCase=U}}class jI extends q{test=null;constructor(O=[]){super(z.MATCH_CASE,O)}}class CO extends q{iterator;iterable;body;constructor(O,I,U=[]){super(z.FOREACH);this.iterator=O,this.iterable=I,this.body=U}}class u extends q{static KIND_SIMPLE="simple";static KIND_GENERIC="generic";static KIND_LAMBDA="lambda";kind;typeArguments=[];parameterTypes=[];returnType=null;nullable;constructor(O,I,U=!1){super(z.TYPE);this.kind=O,this.name=I,this.nullable=U}}class _O extends q{tag;props=new Map;constructor(O,I,U=[]){super(z.VDOM,U);this.tag=O,this.props=I}}class cO extends q{constructor(O){super(z.VDOM_TEXT);this.value=O}}class GO{rules=new i;source;constructor(O){this.source=O}getTokenStream(){return new EU(this.tokenize())}tokenize(){let O=[],I=0,U=1,_=0,L=()=>{let B=this.matchLineCommentAt(I);if(B)return O.push(B.withLineAndColumn(U,_)),I=B.end+1,U++,_=0,!0;return!1},W=()=>{let B=this.matchStringAt(I);if(B)return O.push(B.withLineAndColumn(U,_)),I=B.end+1,_+=this.columOffset(B),!0;return!1},$=()=>{let B=this.matchPunctuationAt(I);if(B)return O.push(B.withLineAndColumn(U,_)),I=B.end+1,_+=this.columOffset(B),!0;return!1},H=()=>{let B=this.matchIdentifierAt(I);if(B){if(O.push(B.withLineAndColumn(U,_)),I=B.end,_+=this.columOffset(B),B.value===E.VDOM){let b=this.tokenizeVDom(I,U,_);O.push(...b.tokens),I=b.newIndex,U=b.line,_=b.column}return!0}return!1},Q=()=>{let B=this.matchNumberAt(I);if(B)return O.push(B.withLineAndColumn(U,_)),I=B.end,_+=this.columOffset(B),!0;return!1},f=()=>{let B=this.matchOperatorAt(I);if(B)return O.push(B.withLineAndColumn(U,_)),I=B.end+1,_+=this.columOffset(B),!0;return!1},Y=()=>{let B=this.matchAnnotationAt(I);if(B)return O.push(B.withLineAndColumn(U,_)),I=B.end+1,_+=this.columOffset(B),!0;return!1};while(I<this.source.length){if(this.source.charAt(I)===`
`)U++,_=0;else _++;if(this.matchWhitespaceAt(I)){I++;continue}if(L()||$()||W()||Q()||H()||f()||Y())continue;WU("Unexpected character: "+this.source.charAt(I))}return O.push(this.eof(I).withLineAndColumn(U,_)),O}eof(O){return new M(Z.EOF,"",O,O,this.source)}columOffset(O){return O.value.length-1}matchWhitespaceAt(O){return this.rules.isWhitespace(this.source.charAt(O))}matchNumberAt(O){if(!this.rules.isNumeric(this.source.charAt(O)))return null;let I=O;while(this.rules.isNumeric(this.source.charAt(O)))O++;return new M(Z.NUMBER,this.source.slice(I,O),I,O,this.source)}matchStringAt(O){if(this.source.charAt(O)!=='"')return null;let I=++O;while(this.source.charAt(O)!=='"')O++;return new M(Z.STRING,this.source.slice(I,O),I,O,this.source)}matchIdentifierAt(O){if(!this.rules.isAlpha(this.source.charAt(O)))return null;let I=O,U=O;while(this.rules.isAlphaNumeric(this.source.charAt(U)))U++;let _=this.source.slice(I,U),L=Z.IDENTIFIER;if([E.TRUE,E.FALSE].includes(_))L=Z.BOOLEAN;else if(i.KEYWORDS.has(_))L=Z.KEYWORD;return new M(L,_,I,U,this.source)}matchOperatorAt(O,I=i.OPERATORS){let U=this.source.charAt(O)+this.source.charAt(O+1);if(I.has(U))return new M(Z.OPERATOR,U,O,O+1,this.source);if(I.has(this.source.charAt(O)))return new M(Z.OPERATOR,this.source.charAt(O),O,O,this.source);return null}matchPunctuationAt(O,I=i.PUNCTUATIONS){let U=this.source.charAt(O)+this.source.charAt(O+1);if(I.has(U))return new M(Z.PUNCTUATION,U,O,O+1,this.source);if(!I.has(this.source.charAt(O)))return null;return new M(Z.PUNCTUATION,this.source.charAt(O),O,O,this.source)}matchLineCommentAt(O){if(!this.source.startsWith(i.COMMENT_LINE,O))return null;let I=O+i.COMMENT_LINE.length;while(I<this.source.length&&this.source.charAt(I)!==`
`)I++;return new M(Z.COMMENT,this.source.slice(O,I),O,I,this.source)}matchAnnotationAt(O){if(this.source.charAt(O)!=="@")return null;let I=O+1,U=O+1;while(this.rules.isAlpha(this.source.charAt(U)))U++;let _=this.source.slice(I,U);return new M(Z.ANNOTATION,_,I,U,this.source)}tokenizeVDom(O,I,U){let _=[],L=O,W="",$=()=>{let C=this.matchStringAt(L);if(C)return B(),_.push(C.withLineAndColumn(I,U)),L=C.end+1,U+=this.columOffset(C),!0;return!1},H=()=>{let C=this.matchPunctuationAt(L,i.DOM_PUNCTUATIONS);if(C)return B(),_.push(C.withLineAndColumn(I,U)),L=C.end+1,U+=this.columOffset(C),!0;return!1},Q=()=>{let C=this.matchIdentifierAt(L);if(C)return B(),_.push(C.withLineAndColumn(I,U)),L=C.end,U+=this.columOffset(C),!0;return!1},f=()=>{let C=this.matchNumberAt(L);if(C)return B(),_.push(C.withLineAndColumn(I,U)),L=C.end,U+=this.columOffset(C),!0;return!1},Y=()=>{let C=this.matchOperatorAt(L,i.DOM_OPERATORS);if(C)return B(),_.push(C.withLineAndColumn(I,U)),L=C.end+1,U+=this.columOffset(C),!0;return!1},B=()=>{if(W.length>0)_.push(new M(Z.TEXT,W,L-W.length,L,this.source).withLineAndColumn(I,U-W.length)),W=""},b=!1;while(L<this.source.length){let C=this.source.charAt(L);if(C===E.SEMICOLON){B(),_.push(new M(Z.PUNCTUATION,C,L,L,this.source).withLineAndColumn(I,U)),L++,U++;break}else if(C===E.BRACE_OPEN)b=!0;else if(C===E.BRACE_CLOSE)b=!1;if(b){if(this.matchWhitespaceAt(L)){L++;continue}}if(H()||$()||f()||Q()||Y())continue;if(W+=C,C===`
`)I++,U=0;else U++;L++}return B(),{tokens:_,newIndex:L,line:I,column:U}}}class EU{tokens;index=0;constructor(O){this.tokens=O}rewind(){if(this.index>0)this.index--}peek(){return this.tokens[this.index]||null}next(){return this.tokens[this.index++]||null}hasNext(){return this.index<this.tokens.length}}class F{static NEWLINE=`
`;url;code;constructor(O,I="<inline>"){this.url=I,this.code=O}get length(){return this.code.length}getTokenizer(){return new GO(this)}slice(O,I){return this.code.slice(O,I)}charAt(O){return this.code.charAt(O)}startsWith(O,I){return this.code.startsWith(O,I)}}class OI{source;start;end;line;column;constructor(O,I,U){this.source=O,this.start=I,this.end=U;let L=O.slice(0,I).split(F.NEWLINE);this.line=L.length,this.column=(L[L.length-1]||"").length+1}text(){return this.source.slice(this.start,this.end)}}function N(O,I){return new OI(O.source,O.start,I.end)}async function kO(O){let I=await fetch(O);if(!I.ok)hO(`Failed to load script: ${O}`);return new F(await I.text(),O)}class LO{static TYPE_ERROR="TypeError";static TOKEN_ERROR="TokenError";static PARSER_ERROR="ParserError";static RUNTIME_ERROR="RuntimeError";static INTERNAL_ERROR="InternalError";static NATIVE_ERROR="NativeError";static DEPENDENCY_ERROR="DependencyError"}class e extends Error{kind;span=null;cause=null;constructor(O,I,U=null,_=null){super(I);this.kind=O,this.span=U,this.cause=_}format(){if(this.span)return`
[${this.kind}] ${this.message}
  at ${this.span.source.url}:${this.span.line}:${this.span.column}

${this.span.text()}
${" ".repeat(this.span.column)}${"^".repeat(this.span.end-this.span.start)}
`;return`[${this.kind}] ${this.message}`}}class $U extends e{constructor(O,I=null,U=null){super(LO.TOKEN_ERROR,O,I,U)}}class HU extends e{constructor(O,I=null,U=null){super(LO.TYPE_ERROR,O,I,U)}}class zU extends e{constructor(O,I=null,U=null){super(LO.PARSER_ERROR,O,I,U)}}class QU extends e{constructor(O,I=null,U=null){super(LO.RUNTIME_ERROR,O,I,U)}}class XU extends e{constructor(O,I=null,U=null){super(LO.NATIVE_ERROR,O,I,U)}}class BU extends e{constructor(O,I=null,U=null){super(LO.DEPENDENCY_ERROR,O,I,U)}}function WU(O,I=null,U=null){throw new $U(O,I,U)}function y(O,I=null,U=null){throw new HU(O,I,U)}function G(O,I=null,U=null){throw new zU(O,I,U)}function X(O,I=null,U=null){throw new QU(O,I,U)}function RO(O,I=null,U=null){throw new XU(O,I,U)}function hO(O,I=null,U=null){throw new BU(O,I,U)}function iO(O,I){if(O instanceof e)return O;return new e(LO.INTERNAL_ERROR,O.message||String(O),new OI(I,0,I.length))}class h{name;nativeInstance;nativeClassSource;isAutoloadAble=!1;constructor(O,I,U){this.name=O,this.nativeInstance=I,this.nativeClassSource=U}getClassDefinition(){let O=new n(this.nativeClassSource).parse();for(let I of O.children)if(I.type===z.CLASS){if(I instanceof v&&I.name===this.name){let U=d.fromAST(I);return U.nativeInstance=this.nativeInstance,U}}X(`Class ${this.name} not found.`,O.span)}}class w{className;constructor(O){this.className=O}serialize(){let O={};return O[this.className]=Object.keys(this).filter((I)=>I!=="className").reduce((I,U)=>{let _=Object.assign({},this);return I[U]=_[U],I},{}),O}toString(){return JSON.stringify({className:this.className},null,2)}}class JU extends w{__instance;constructor(O){super(O.__classDef.name);return this.__instance=O,new Proxy(this,{get:(I,U)=>{if(U in this.__instance.__instanceFields)return this.__instance.__instanceFields[U];if(U in this.__instance.__staticFields)return this.__instance.__staticFields[U];if(U in this)return this[U]},set:(I,U,_)=>{if(U in this.__instance.__instanceFields)this.__instance.__instanceFields[U]=_;if(U in this.__instance.__staticFields)this.__instance.__staticFields[U]=_}})}serialize(){let O={};return O[this.className]={...this.__instance?.__instanceFields},O}toString(){return JSON.stringify(this.serialize(),null,2)}}function P(O,I=null){let U=typeof O;if(I===null){if(O===E.NULL)return null;if(O===E.TRUE)return!0;if(O===E.FALSE)return!1;if(U==="string"&&O.trim()!==""&&!isNaN(O))return Number(O);return O}switch(I){case K.STRING:return U==="string"?O:String(O);case K.NUMBER:return U==="number"?O:Number(O);case K.BOOLEAN:return U==="boolean"?O:O==="true";case K.NULL:return null}return O}function I_(O){let I=new q(z.STRING);return I.value=O,I}function U_(O){let I=new q(z.NUMBER);return I.value=O,I}function __(O){let I=new q(z.BOOLEAN);return I.value=O,I}function L_(){let O=new q(z.NULL);return O.value=E.NULL,O}function E_(O){let I=new m;return I.elements=O.map((U)=>II(U)),I}function II(O){if(O instanceof q)return O;if(typeof O===K.STRING)return I_(O);if(typeof O===K.NUMBER)return U_(O);if(typeof O===K.BOOLEAN)return __(O);if(O===null||O===void 0)return L_();if(Array.isArray(O))return E_(O);RO("Cannot convert native object to Lyra value")}function OO(O){if(O instanceof q)return P(O.value);if(O instanceof IO){if(O.__nativeInstance)return O.__nativeInstance;return new JU(O)}if(Array.isArray(O))return O.map(OO);return P(O)}function mO(O){let I=new r;return I.argument=II(O),I}function jO(O,I){if(!I.classes.has(O.className))RO(`Class ${O.className} not found.`);let _=I.classes.get(O.className).constructEmptyInstance(I);return _.__nativeInstance=O,_}var xO="String";class UI extends w{value;constructor(O){super(xO);this.value=O}toUpperCase(){return new UI(this.value.toUpperCase())}toLowerCase(){return new UI(this.value.toLowerCase())}toString(){return this.value}}class _I extends h{static CLASS_NAME=xO;constructor(){super(xO,UI,new F(`
class ${xO} {
	public constructor(value);
				
	public toUpperCase(): ${xO};
	
	public toLowerCase(): ${xO};

	public toString(): string;
}`));this.isAutoloadAble=!0}}var xI="System";class fU{static alert(O){alert(O)}static print(O){console.log(O)}static info(O){if(O instanceof w){console.info(O.serialize());return}console.info(O)}static warning(O){if(O instanceof w){console.warn(O.serialize());return}console.warn(O)}static error(O){if(O instanceof w){console.error(O.serialize());return}console.error(O)}static log(O){if(O instanceof w){console.log(O.serialize());return}console.log(O)}}class LI extends h{static CLASS_NAME=xI;constructor(){super(xI,fU,new F(`
class ${xI} {
	public static alert(message: string): void;
	
	public static print(message: string): void;
	
	public static info(value: mixed): void;
	
	public static warning(value: mixed): void;
	
	public static error(value: mixed): void;
	
	public static log(value: mixed): void;
}`));this.isAutoloadAble=!1}}var SI="Assert",ZU=(O="")=>{throw Error("[AssertionError] "+(O||"Assertion failed."))};class qU{static isTrue(O,I=""){if(!O)ZU(I)}static isFalse(O,I=""){if(O)ZU(I)}}class EI extends h{static CLASS_NAME=SI;constructor(){super(SI,qU,new F(`
class ${SI} {
	public static isTrue(condition: boolean, message: string = ""): void;
	
	public static isFalse(condition: boolean, message: string = ""): void;
}`));this.isAutoloadAble=!1}}var WI="Number";class KU extends w{value;constructor(O){super(WI);this.value=O}toString(){return this.value.toString()}}class $I extends h{static CLASS_NAME=WI;constructor(){super(WI,KU,new F(`
class ${WI} {
	public constructor(value);

	public toString(): string;
}`));this.isAutoloadAble=!0}}var HI="Array",zI="ArrayIterator";class EO extends w{values;constructor(O=[]){super(HI);this.values=O}iterator(){return new YU(this)}length(){return this.values.length}push(O){this.values.push(O)}get(O){return this.values[O]??null}removeAt(O){this.values=this.values.splice(O,1)}toString(){return`[${this.values.map((I)=>{if(I instanceof EO)return I.toString();return I}).join(", ")}]`}}class QI extends h{static CLASS_NAME=HI;constructor(){super(HI,EO,new F(`
class ${HI}<T> implements Iterable<T> {
	public constructor(values = []);
	
	public iterator(): Iterator<T>;
	
	public length(): number;
	
	public push(value: T): void;
	
	public get(index: number): T?;
	
	public removeAt(index: number): void;
	
	public toString(): string;
}`));this.isAutoloadAble=!0}}class YU extends w{values;index=0;constructor(O){super(zI);this.values=O.values}rewind(){this.index=0}hasNext(){return this.index<this.values.length}next(){if(this.index+1>this.values.length)return;this.index++}previous(){if(this.index+1<0)return;this.index--}key(){return this.index}current(){return this.values[this.index]}}class XI extends h{static CLASS_NAME=zI;constructor(){super(zI,EO,new F(`
class ${zI}<T> implements Iterator<T> {
	public constructor(array: Array<T>);
	
	public hasNext(): boolean;
	
	public next(): void;
	
	public previous(): void;
	
	public key(): number;
	
	public current(): T;
	
	public rewind(): void;
}`));this.isAutoloadAble=!0}}class lO{value;subscribers=new Map;id=0;constructor(O){this.value=O}get(){return this.value}set(O){if(this.value===O)return;this.value=O,this.notify()}subscribe(O){let I=this.id++;return this.subscribers.set(I,this.wrapCallback(O)),I}unsubscribe(O){return this.subscribers.delete(O)}notify(){for(let O of this.subscribers.values())O(this.value)}wrapCallback(O){return(I)=>{O.evalCall(null,II(I))}}}var BI="State";class CU extends w{state;constructor(O){super(BI);this.state=new lO(O)}get(){return this.state.get()}set(O){this.state.set(O)}subscribe(O){return this.state.subscribe(O)}unsubscribe(O){return this.state.unsubscribe(O)}}class JI extends h{static CLASS_NAME=BI;constructor(){super(BI,CU,new F(`
class ${BI}<T> {
	public constructor(initial: T);

	public get(): T;
	
	public set(value: T): void;
	
	public subscribe(fn: (T) -> mixed): number;
	
	public unsubscribe(id: number): boolean;
}`));this.isAutoloadAble=!0}}var fI="LyraEvents";class kU extends w{event;constructor(O){super(fI);this.event=O}getType(){return this.event.type}preventDefault(){this.event.preventDefault()}}class SO extends h{static CLASS_NAME=fI;constructor(){super(fI,kU,new F(`
class ${fI} {
	public constructor(event);

	public getType(): string;

	public preventDefault(): void;
}`));this.isAutoloadAble=!0}}class sO{registry=new Map;constructor(){this.registry.set(EI.CLASS_NAME,new EI),this.registry.set(LI.CLASS_NAME,new LI),this.registry.set(_I.CLASS_NAME,new _I),this.registry.set($I.CLASS_NAME,new $I),this.registry.set(QI.CLASS_NAME,new QI),this.registry.set(XI.CLASS_NAME,new XI),this.registry.set(JI.CLASS_NAME,new JI),this.registry.set(SO.CLASS_NAME,new SO)}}class ZI{name;parameterNodes=[];returnType;constructor(O,I,U){this.name=O,this.parameterNodes=I,this.returnType=U}}class FU{functions=new Map;has(O){return this.functions.has(O)}get(O){let I=this.functions.get(O);if(!I)RO(`Function ${O} not found.`);return I}set(O,I,U){return this.functions.set(O,new ZI(O,I,U)),this}}class wO{static PRINT="print";getGlobalFunctions(){return{[wO.PRINT]:(...O)=>{console.log(...O)}}}getGlobalFunctionTypeRegistry(){let O=new FU;return O.set(wO.PRINT,[W_(wU(K.STRING),"message")],wU(K.VOID)),O}}function wU(O,I=!1){return new u(u.KIND_SIMPLE,O,I)}function W_(O,I,U=null){return new PO(I,O,U)}class t{static NUMBER=K.NUMBER;static STRING=K.STRING;static BOOLEAN=K.BOOLEAN;static MIXED=K.MIXED;static NULL=K.NULL;static VOID=K.VOID;static hasType(O){return Object.hasOwnProperty.call(t,O.toUpperCase())}}class gO{static ARRAY=K.ARRAY;static CLASSNAME_MAP={array:"Array"};static getClassRefName(O){return gO.CLASSNAME_MAP[O]||null}}class c{name;constructor(O){this.name=O}equals(O){return this===O}accepts(O){return this.equals(O)}toString(){return`Type(${this.name})`}}class yO extends c{constructor(O){super(O)}equals(O){return O instanceof yO&&this.name===O.name}}class dO extends c{constructor(){super(t.MIXED)}equals(O){return O instanceof dO}accepts(){return!0}}class KI extends c{constructor(){super(t.VOID)}equals(O){return O instanceof KI}}class MI extends c{constructor(){super(t.NULL)}equals(O){return O instanceof MI}}class UO extends c{inner;constructor(O){super(O.toString()+"?");this.inner=O}equals(O){if(O===J.NULL)return!0;if(O instanceof UO)return this.inner.equals(O.inner);return!1}accepts(O){return O===J.NULL||this.inner.accepts(O)}toString(){return this.inner.toString()+"?"}}class DU extends c{constructor(){super("vnode")}equals(O){return O instanceof KI}}class J{static NUMBER=new yO(t.NUMBER);static STRING=new yO(t.STRING);static BOOLEAN=new yO(t.BOOLEAN);static MIXED=new dO;static NULL=new MI;static VOID=new KI;static VNODE=new DU;static getType(O){if(!Object.hasOwnProperty.call(t,O.toUpperCase()))y(`Unknown primitive type ${O}.`);return J[O.toUpperCase()]}}class j extends c{constructor(O){super(O)}equals(O){return O instanceof j&&this.name===O.name}accepts(){return!0}}class NO{name;variableType;constructor(O){this.name=O,this.variableType=new j(O)}}class YI{node;name;fieldType;isStatic=!1;isPrivate=!1;isPublic=!1;isReadonly=!1;owner=null;constructor(O,I){this.node=O,this.name=O.name,this.fieldType=I,this.isStatic=O.modifiers.static,this.isPrivate=O.modifiers.private,this.isPublic=O.modifiers.public,this.isReadonly=O.modifiers.readonly}}class CI{node;name;parameterType;defaultType=null;constructor(O,I,U=null,_=null){this.name=O,this.parameterType=I,this.defaultType=U,this.node=_}}class kI{name;node;isStatic=!1;isPrivate=!1;isPublic=!1;typeParameterSymbols=[];parameterSymbols=[];returnType=J.MIXED;owner=null;constructor(O){this.name=O.name,this.node=O,this.isStatic=O.modifiers.static,this.isPrivate=O.modifiers.private,this.isPublic=O.modifiers.public}get body(){return this.node.children}}class $O{node;name;superClass=null;superClassSymbol=null;typeParameterSymbols=[];instanceFieldSymbols=new Map;staticFieldSymbols=new Map;instanceMethodSymbols=new Map;staticMethodSymbols=new Map;constructorMethodSymbol=null;implementsInterfaces=[];constructor(O){this.node=O,this.name=O.name,this.superClass=O.superClass?.name??null}resolveInstanceFieldSymbol(O){if(this.instanceFieldSymbols.has(O))return this.instanceFieldSymbols.get(O)||null;if(this.superClass)return this.superClassSymbol?.resolveInstanceFieldSymbol(O)||null;return null}resolveStaticFieldSymbol(O){if(this.staticFieldSymbols.has(O))return this.staticFieldSymbols.get(O)||null;if(this.superClass)return this.superClassSymbol?.resolveStaticFieldSymbol(O)||null;return null}}class bI{node;name;typeParameterSymbols=[];staticFieldSymbols=new Map;instanceMethodSymbols=new Map;extendsInterfaces=[];constructor(O){this.node=O,this.name=O.name}}class D extends c{classSymbol;typeArguments;constructor(O,I=[]){super(D.formatSymbolName(O.name,I));this.classSymbol=O,this.typeArguments=I}static formatSymbolName(O,I){if(I.length===0)return`classRefType(${O})`;return`classRefType(${O}<${I.map((U)=>U.toString()).join(", ")}>)`}equals(O){return O instanceof D&&O.classSymbol===this.classSymbol}accepts(O){if(!this.equals(O))return!1;if(O instanceof D){if(this.typeArguments.length!==O.typeArguments.length)return!1;for(let I=0;I<this.typeArguments.length;I++){let U=O.typeArguments[I];if(!U||!this.typeArguments[I]?.accepts(U))return!1}return!0}return!1}}class WO extends c{interfaceSymbol;typeArguments;constructor(O,I=[]){super(WO.formatSymbolName(O.name,I));this.interfaceSymbol=O,this.typeArguments=I}static formatSymbolName(O,I){if(I.length===0)return`interfaceRefType(${O})`;return`interfaceRefType(${O}<${I.map((U)=>U.toString()).join(", ")}>)`}equals(O){return O instanceof WO&&O.interfaceSymbol===this.interfaceSymbol}accepts(O){if(!this.equals(O))return!1;if(O instanceof WO){if(this.typeArguments.length!==O.typeArguments.length)return!1;for(let I=0;I<this.typeArguments.length;I++){let U=O.typeArguments[I];if(!U||!this.typeArguments[I]?.accepts(U))return!1}return!0}return!1}}class FO extends c{parameterSymbols=[];returnType;constructor(O,I){super(FO.createSignature(O,I));this.parameterSymbols=O,this.returnType=I}static createSignature(O,I){return`lambda(${O.map((U)=>U.parameterType.toString()).join(", ")}) -> ${I.toString()})`}equals(O){if(!(O instanceof FO))return!1;if(this.parameterSymbols.length!==O.parameterSymbols.length)return!1;for(let I=0;I<this.parameterSymbols.length;I++){let U=O.parameterSymbols[I]?.parameterType;if(!U||!this.parameterSymbols[I]?.parameterType.accepts(U))return!1}return this.returnType.accepts(O.returnType)}}class V{parent;types=new Map;typeBindings=new Map;currentObjectSymbol;constructor(O=null){this.parent=O,this.currentObjectSymbol=O?.currentObjectSymbol??null}defineType(O,I){this.types.set(O,I)}defineTypeBinding(O,I){this.typeBindings.set(O,I)}hasType(O){return this.types.has(O)||this.parent?.hasType(O)||!1}hasTypeBinding(O){return this.typeBindings.has(O)||this.parent?.hasTypeBinding(O)||!1}getType(O){if(this.types.has(O))return this.types.get(O)||J.NULL;return this.parent?.getType(O)||J.NULL}getTypeBinding(O){if(this.typeBindings.has(O))return this.typeBindings.get(O)||J.NULL;return this.parent?.getTypeBinding(O)||J.NULL}}function qI(O,I,U=null){let _=NI(O,I,U);if(_){if(!(_ instanceof UO)&&O.nullable)return new UO(_);return _}y(`Could not resolve type ${O.name}.`,O.span)}function NI(O,I,U=null){switch(O.kind){case u.KIND_SIMPLE:{if(U&&U.hasTypeBinding(O.name))return U.getTypeBinding(O.name);if(I.types.hasSymbol(O.name))return $_(O,I);if(t.hasType(O.name))return z_(O);return new j(O.name)}case u.KIND_GENERIC:{if(!I.types.hasSymbol(O.name))y(`Symbol ${O.name} is not a class reference.`,O.span);return H_(O,I)}case u.KIND_LAMBDA:return Q_(O,I);default:y(`Invalid type annotation, kind ${O.kind}.`,O.span)}}function $_(O,I){if(O.typeArguments.length>0)y(`Generic class ${O.name} cannot have type arguments.`,O.span);if(I.types.classSymbols.has(O.name))return new D(I.types.getClassSymbol(O.name));if(I.types.interfaceSymbols.has(O.name))return new WO(I.types.getInteraceSymbol(O.name));y(`Unknown class or interface ${O.name}.`,O.span)}function H_(O,I){if(I.types.classSymbols.has(O.name))return new D(I.types.getClassSymbol(O.name),O.typeArguments.map((U)=>NI(U,I)));if(I.types.interfaceSymbols.has(O.name))return new WO(I.types.getInteraceSymbol(O.name),O.typeArguments.map((U)=>NI(U,I)));y(`Unknown class or interface ${O.name}.`,O.span)}function z_(O){return J.getType(O.name)}function Q_(O,I,U=null){let _=O.parameterTypes.map((L)=>{return new CI(L.name,qI(L,I,U))});return new FO(_,O.returnType?qI(O.returnType,I,U):J.MIXED)}function DO(O,I){if(O instanceof j)return I.get(O.name)??O;if(O instanceof D)return new D(O.classSymbol,O.typeArguments.map((U)=>DO(U,I)));if(O instanceof UO)return new UO(DO(O.inner,I));return O}function vI(O,I){let U=new Map;for(let _=0;_<O.length;_++){let L=O[_]||null,W=I[_]||null;if(L&&W)U.set(L.name,W)}return U}class A{static NUMBER="Number";static STRING="String";static BOOLEAN="Boolean";static CLASSNAME_MAP={number:A.NUMBER,string:A.STRING,boolean:A.BOOLEAN};static getClassName(O){let I=A.CLASSNAME_MAP[O];if(!I)X(`No class found for primitive type ${O}.`);return I}}class nO{static CLASSNAME_MAP=new Map([[J.NUMBER,A.NUMBER],[J.STRING,A.STRING],[J.BOOLEAN,A.BOOLEAN]]);static autoboxIfNeeded(O,I){let U=nO.CLASSNAME_MAP.get(O);if(U)return new D(I.types.getClassSymbol(U));return O}}var X_=new sO,uU=new wO,TI=uU.getGlobalFunctions(),B_=uU.getGlobalFunctionTypeRegistry();class cI{node;objectRegistry;functionEnv;eventPipeline;constructor(O,I,U,_){this.node=O,this.objectRegistry=I,this.functionEnv=U,this.eventPipeline=_}getASTCallNode(){if(!(this.node instanceof p))X(`Invalid native function call ${this.node.type}.`,this.node.span);return this.node}getASTLambdaNode(){if(!(this.node instanceof l))X(`Invalid lambda call ${this.node.type}.`,this.node.span);return this.node}}class RI extends cI{evalCall(O,...I){let U=this.getASTLambdaNode(),_=new x(this.functionEnv);for(let L=0;L<U.parameters.length;L++){let W=U.parameters[L]||null;if(!W)continue;_.define(W.name,I[L])}return HO(U.children,this.objectRegistry,_,this.eventPipeline,O,U.returnType)}}class PU extends cI{evalCall(O,...I){let U=this.getASTCallNode(),_=this.resolveCall(O)[U.callee.name](...I);if(_ instanceof w)_=jO(_,this.objectRegistry);else _=mO(_);return HO([_],this.objectRegistry,this.functionEnv,this.eventPipeline,O,this.lookupFunctionType(U.callee.name).returnType)}lookupFunctionType(O){return B_.get(O)}resolveCall(O){let I=this.getASTCallNode();if(I===null)X("Invalid function call.");return k(I.callee,this.objectRegistry,this.functionEnv,this.eventPipeline,O)}}function VU(O,I){for(let U of X_.registry.values())if(U.isAutoloadAble){let _=U.getClassDefinition();O.classes.set(U.name,_),I.define(U.name,_)}}function GU(O){for(let I in TI){if(!TI[I])X("Global function is null.");O.define(I,TI)}}function zO(O,I,U,_,L=null){if(O.isExpression)return new MO(k(O,I,U,_,L));switch(O.type){case z.PROGRAMM:{for(let W of O.children)zO(W,I,U,_,L);return null}case z.IMPORT:case z.INTERFACE:return null;case z.CLASS:{if(O instanceof v)return q_(O,I,U,_);X(`Invalid class node ${O.type}.`,O.span)}case z.VARIABLE:{if(O instanceof ZO){let W=O.init?k(O.init,I,U,_,L):null;return U.define(O.name,W),null}X(`Invalid variable node ${O.type}.`,O.span)}case z.IF:{if(O instanceof VO)return jU(O,I,U,_,L);X(`Invalid if node ${O.type}.`,O.span)}case z.MATCH:{if(O instanceof AO)return G_(O,I,U,_,L);X(`Invalid match node ${O.type}.`,O.span)}case z.FOREACH:{if(O instanceof CO)return h_(O,I,U,_,L);X(`Invalid foreach node ${O.type}.`,O.span)}case z.VDOM:{if(O instanceof _O)return xU(O,I,U,_,L);X(`Invalid foreach node ${O.type}.`,O.span)}case z.EXPRESSION:{if(O instanceof qO)return k(O.expr,I,U,_,L);X(`Invalid expression node ${O.type}.`,O.span)}case z.RETURN:{if(O instanceof r){let W=O.argument?k(O.argument,I,U,_,L):null;return new MO(W)}X(`Invalid return node ${O.type}.`,O.span)}default:X(`Unhandled node ${O.type}.`,O.span)}}function J_(O,I){let U;if(I.classes.has(O.name))U=I.classes.get(O.name);else U=d.fromAST(O),I.classes.set(O.name,U);return U.constructEmptyInstance(I)}function f_(O,I,U,_,L){return I.constructNativeInstanceByNewNode(O,U,_,L)}function Z_(O,I,U,_,L){return I.constructInstanceByNewNode(O,U,_,L)}function q_(O,I,U,_){let L=J_(O,I);L.initializeInstanceFields(I,U,_),U.define(O.name,L)}function K_(O,I,U,_){if(!I.classes.has(O.name))X(`Unknown class ${O.name}.`,O.span);let L=I.classes.get(O.name);if(L.nativeInstance)return f_(O,L,I,U,_);return Z_(O,L,I,U,_)}function k(O,I,U,_,L=null){switch(O.type){case z.STRING:case z.NUMBER:case z.BOOLEAN:return O.value;case z.NULL:return null;case z.IDENTIFIER:return U.get(O.name);case z.THIS:{if(!L)X("this used outside of method.",O.span);return L}case z.BINARY:{if(O instanceof BO)return Y_(O,I,U,_,L);X(`Invalid binary expression ${O.type}`)}case z.UNARY:{if(O instanceof JO)return j_(O,I,U,_,L);X(`Invalid unary expression ${O.type}.`,O.span)}case z.ASSIGNMENT:{if(O instanceof TO)return F_(O,I,U,_,L);X(`Invalid assignment expression ${O.type}`,O.span)}case z.MEMBER:{if(O instanceof S)return D_(O,U);X(`Invalid member expression ${O.type}`,O.span)}case z.CALL:{if(O instanceof p)return g_(O,I,U,_,L);X(`Invalid call expression ${O.type}`,O.span)}case z.VDOM:{if(O instanceof _O)return xU(O,I,U,_,L);X(`Invalid call expression ${O.type}`,O.span)}case z.NEW:{if(O instanceof o)return K_(O,I,U,_);X(`Invalid call expression ${O.type}`,O.span)}case z.ARRAY:{if(O instanceof m)return C_(O,I,U,_,L);X(`Invalid array expression ${O.type}`,O.span)}case z.INDEX:{if(O instanceof fO)return k_(O,I,U,_,L);X(`Invalid index expression ${O.type}`,O.span)}case z.LAMBDA:{if(O instanceof l)return w_(O,I,U,_);X(`Invalid lambda expression ${O.type}`,O.span)}default:X(`Unhandled expression ${O.type}.`,O.span)}}function Y_(O,I,U,_,L=null){let W=P(k(O.left,I,U,_,L)),$=P(k(O.right,I,U,_,L));switch(O.operator){case E.PLUS:return W+$;case E.MINUS:return W-$;case E.MULTIPLY:return W*$;case E.DIVIDE:return W/$;case E.MODULUS:return W%$;case E.LESS_THAN:return W<$;case E.GREATER_THAN:return W>$;case E.LESS_EQUAL:return W<=$;case E.GREATER_EQUAL:return W>=$;case E.EQUAL:return W===$;case E.NOT_EQUAL:return W!==$;case E.AND:return W&&$;case E.OR:return W||$;default:X(`Unknown operator ${O.operator}`)}}function C_(O,I,U,_,L=null){let W=[];for(let Q of O.elements)W.push(k(Q,I,U,_,L));let $=I.classes.get("Array"),H=$.constructEmptyInstance(I);return H.__nativeInstance=new $.nativeInstance(OO(W)),H}function k_(O,I,U,_,L=null){if(!O.object)X("Index access on null.",O.span);if(!O.index)X("Access with unspecific index.",O.span);let W=k(O.object,I,U,_,L),$=k(O.index,I,U,_,L);if(!(W instanceof EO||W.__nativeInstance instanceof EO))X("Index access on non-array",O.span);let Q=(W instanceof EO?W:W.__nativeInstance).values[$];if(Q instanceof w)return jO(Q,I);return Q}function w_(O,I,U,_){return new RI(O,I,U,_)}function F_(O,I,U,_,L=null){let W=k(O.right,I,U,_,L);if(O.left.type===z.MEMBER)if(O.left instanceof S){let $=k(O.left.object,I,U,_,L);if(O.left.object.type===z.IDENTIFIER)$.__staticFields[O.left.property]=W;else $.__instanceFields[O.left.property]=W;$.markDirty(_)}else X(`Invalid member expression ${O.type}`,O.span);else U.set(O.left.name,W);return W}function D_(O,I){let U=I.get(O.object.name);if(O.property in U.__instanceFields)return U.__instanceFields[O.property];if(O.property in U.__staticFields)return U.__staticFields[O.property]}function g_(O,I,U,_,L=null){if(O.callee.type===z.IDENTIFIER&&O.callee.name===E.SUPER){if(!L||!L.__classDef?.superClass)X("super() used outside of subclass constructor");let $=I.classes.get(L.__classDef.superClass).constructorMethod;if(!$)return null;let H=new x(U);H.define(E.THIS,L),mI(O,$.parameters,I,H,U,_,L);for(let Q of $.children)zO(Q,I,H,_,L);return null}if(O.callee.type===z.MEMBER){if(O.callee instanceof S){if(O.callee.object.type===z.IDENTIFIER){let W=O.callee.object.name;if(I.classes.has(W))return P_(O,W,I,U,_,L)}return hU(O,I,U,_,L)}return null}return u_(O,I,U,_,L)}function u_(O,I,U,_,L=null){let W=k(O.callee,I,U,_,L),$=V_(O,I,U,_,L);if(W instanceof RI)return W.evalCall(L,...$);return new PU(O,I,U,_).evalCall(L,...$)}function P_(O,I,U,_,L,W=null){if(!(O.callee instanceof S))X(`Invalid member expression ${O.type}`,O.span);let $=U.classes.get(I),H=$.staticMethods[O.callee.property];if(!H)X(`Static method ${I}.${O.callee.property} not found`,O.callee.span);if($.nativeInstance&&$.nativeInstance[H.name]){let Y=bO(O,H.parameters,U,_,L,W).map(OO),B=$.nativeInstance[H.name](...Y);if(B instanceof w)return jO(B,U);return HO([mO(B)],U,new x(_),L,W,H.returnType)}let Q=new x(_);return mI(O,H.parameters,U,Q,_,L,W),HO(H.children,U,Q,L,W,H.returnType)}function hU(O,I,U,_,L=null){if(!(O.callee instanceof S))X(`Invalid member expression ${O.type}`,O.span);let W=k(O.callee.object,I,U,_,L);if(W=x_(W,I),!W||!W.__classDef)X("Instance call on non-object",O.callee.span);let $=W.__classDef;if(O.callee.object.type===z.IDENTIFIER&&O.callee.object.name==="super"){let f=$.superClass;if(!f)X("super used but no superclass",O.callee.span);$=I.classes.get(f)}let H=iI($,I,O.callee.property);if(!H)X(`Method ${O.callee.property} not found on ${$.name}`,O.callee.span);let Q=new x(U);if(Q.define(E.THIS,W),W.__nativeInstance&&H.name in W.__nativeInstance){let Y=bO(O,H.parameters,I,U,_,L).map(OO),B=W.__nativeInstance[H.name](...Y);if(B instanceof w)return jO(B,I);return HO([mO(B)],I,Q,_,W,H.returnType)}return mI(O,H.parameters,I,Q,U,_,L),HO(H.children,I,Q,_,W,H.returnType)}function iI(O,I,U){if(O.instanceMethods[U])return O.instanceMethods[U];if(O.superClass){let _=I.classes.get(O.superClass);return iI(_,I,U)}return null}function mI(O,I,U,_,L,W,$=null){let H=O.arguments;for(let Q=0;Q<I.length;Q++){let f=I[Q]||null,Y=H[Q]||null;if(!f)X("Missing parameter name in method call.");let B;if(Y)B=k(Y,U,L,W,$);else if(f?.defaultValue)B=k(f.defaultValue,U,L,W,$);let b=f.typeAnnotation?P(B,f.typeAnnotation.name):P(B,K.MIXED);_.define(f.name,b)}}function V_(O,I,U,_,L=null){if(O.callee instanceof l){let H=O.callee;return bO(O,H.parameters,I,U,_,L)}if(O.callee.type===z.IDENTIFIER)return O.arguments.map((H)=>{return P(k(H,I,U,_,L),H.type)});let W="unknown",$="unknown";if(O.callee instanceof S)W=O.callee.object.name,$=O.callee.property;X(`Unknown function ${W}.${$}`,O.span)}function bO(O,I,U,_,L,W=null){let $=[];for(let H=0;H<I.length;H++){let Q=I[H]||null,f=O.arguments[H]||null,Y;if(f)Y=k(f,U,_,L,W);else if(Q?.defaultValue)Y=k(Q.defaultValue,U,_,L,W);else X(`[RuntimeError] Missing argument '${Q?.name}'`,O.span);$.push(Y)}return $.map((H,Q)=>{let f=I[Q];return f?.typeAnnotation?P(H,f.typeAnnotation.name):P(H,K.MIXED)})}function jU(O,I,U,_,L=null){if(P(k(O.condition,I,U,_,L),K.BOOLEAN)===!0)return tO(O.then.children,I,new x(U),_,L);if(O.else){if(O.else instanceof VO)return jU(O.else,I,U,_,L);return tO(O.else.children,I,new x(U),_,L)}return null}function G_(O,I,U,_,L=null){let W=k(O.expression,I,U,_);for(let $ of O.cases){if($.test===null)continue;if(k($.test,I,U,_,L)===W)return gU($,I,U,_,L)}if(O.defaultCase)return gU(O.defaultCase,I,U,_,L);return null}function gU(O,I,U,_,L=null){return tO(O.children,I,new x(U),_,L)}function h_(O,I,U,_,L=null){let W=k(O.iterable,I,U,_,L);if(!(W instanceof IO))X("foreach expects an object implementing Iterable",O.iterable.span);if(!iI(W.__classDef,I,"iterator"))X("Object does not implement Iterable (missing iterator())",O.iterable.span);let H=hU((()=>{return new p(new S(O.iterable,"iterator"))})(),I,U,_,L);if(!(H instanceof IO))X("iterator() must return an Iterator object",O.iterable.span);wI(H,"rewind",I,U,_);while(wI(H,"hasNext",I,U,_)){let Q=wI(H,"current",I,U,_),f=new x(U);f.define(O.iterator,Q);let Y=tO(O.body,I,f,_,L);if(Y instanceof MO)return Y;wI(H,"next",I,U,_)}return null}function wI(O,I,U,_,L){return aO(O,O.findeMethodNode(I),[],U,_,L)}function j_(O,I,U,_,L=null){let W=k(O.argument,I,U,_,L);switch(O.operator){case E.EXCLAMATION_MARK:return!P(W)}X(`Unsupported unary operator ${O.operator}`,O.span)}function xU(O,I,U,_,L=null){let W={};for(let[Q,f]of O.props)W[Q]=k(f,I,U,_,L);let $=[],H={tag:O.tag,isComponent:I.classes.has(O.tag),parent:null,component:null,props:W,children:$,dom:null};for(let Q of O.children)if(Q instanceof cO)$.push(Q.value);else{let f=k(Q,I,U,_,L);f.parent=H,$.push(f)}return H}function HO(O,I,U,_,L=null,W=null){try{return tO(O,I,U,_,L,W)}catch($){if($ instanceof FI)return P($.returnValue.value,$.returnType?.name);throw $}}function tO(O,I,U,_,L=null,W=null){for(let $ of O){let H=zO($,I,U,_,L);if(H instanceof MO)throw new FI(H,W)}return null}function SU(O){switch(O.type){case z.STRING:case z.NUMBER:case z.BOOLEAN:case z.IDENTIFIER:return P(O.value);case z.ARRAY:{if(O instanceof m)return O.elements.map((I)=>SU(I));X(`Invalid annotation property value: ${O.type}`,O.span)}default:X(`Unsupported annotation expression: ${O.type}`,O.span)}}function NU(O){let I={};for(let[U,_]of O.properties)I[U]=SU(_);return I}function aO(O,I,U,_,L,W){let $=new x(L);if($.define(E.THIS,O),O.__nativeInstance&&I.name in O.__nativeInstance){let H=U.map(OO),Q=O.__nativeInstance[I.name](...H);if(Q instanceof w)return jO(Q,_);return HO([mO(Q)],_,$,W,O,I.returnType)}for(let H=0;H<I.parameters.length;H++){let Q=I.parameters[H]||null,f=U[H]||null;if(!Q)X("Method parameter is null.");let Y;if(!f)Y=Q.defaultValue?zO(Q.defaultValue,_,$,W,O):null;else Y=U[H];$.define(Q.name,Y)}return HO(I.children,_,$,W,O,I.returnType)}function x_(O,I){if(O instanceof IO)return O;if(typeof O===K.NUMBER)return AI(A.getClassName(K.NUMBER),O,I);if(typeof O===K.STRING)return AI(A.getClassName(K.STRING),O,I);if(typeof O===K.BOOLEAN)return AI(A.getClassName(K.BOOLEAN),O,I);return O}function AI(O,I,U){let _=U.classes.get(O),L=_.constructEmptyInstance(U);return L.__nativeInstance=new _.nativeInstance(OO(I)),L}var S_={LYRA_INSTANCE_DIRTY_STATE:"lyra:instance_dirty_state",LYRA_INSTANCE_CLEAN_STATE:"lyra:instance_clean_state"},pO=S_;class x{parent;values;constructor(O=null){this.parent=O,this.values=Object.create(null)}define(O,I){this.values[O]=I}get(O){if(O in this.values)return this.values[O];if(this.parent)return this.parent.get(O);X(`Undefined variable ${O}`)}set(O,I){if(O in this.values){this.values[O]=I;return}if(this.parent){this.parent.set(O,I);return}X(`Undefined variable ${O}`)}has(O){return this.values[O]||this.parent&&this.parent.has(O)}}class IO{id;__classDef;__fieldsInitialized=!1;__instanceFields;__staticFields;__nativeInstance=null;__isDirty=!1;constructor(O){this.__classDef=O,this.__instanceFields={},this.__staticFields={},this.__nativeInstance=null,this.id=IO.generateInstanceUUID()}static generateInstanceUUID(){return self.crypto.randomUUID()}markDirty(O){this.__isDirty=!0,O.emit(pO.LYRA_INSTANCE_DIRTY_STATE,{instance:this})}markClean(O){this.__isDirty=!1,O.emit(pO.LYRA_INSTANCE_CLEAN_STATE,{instance:this})}findeMethodNode(O){return this.__classDef.findMethodNode(O)}hasPublicProperty(O){try{return this.__classDef.findInstanceFieldDefinition(O).modifiers.public}catch(I){}return!1}setPublicProperty(O,I,U=null){if(this.__classDef.findInstanceFieldDefinition(O).modifiers.public){this.__instanceFields[O]=P(I,U);return}X(`Field ${O} is not public.`)}initializeInstanceFields(O,I,U){this.__classDef.initializeInstanceFields(this,O,I,U)}}class lI{open=!1;public=!1;private=!1;static=!1;readonly=!1;constructor(O={}){for(let I of Object.keys(O))if(this.hasOwnProperty(I)){let U=this;U[I]=O[I]}}}class sI{type;name;constructor(O,I){this.type=O,this.name=I}}class FI extends Error{returnValue;returnType;constructor(O,I){super("Execution stoppend with return.");this.returnValue=O;this.returnType=I}}class MO{value;constructor(O){this.value=O}}class DI{name;type;modifiers;initializer=null;constructor(O,I,U,_=null){this.name=O,this.type=I,this.modifiers=U,this.initializer=_}}class yI{name;parameters;returnType;modifiers;children;isConstructor;constructor(O,I,U,_,L){this.name=O,this.parameters=I,this.returnType=U,this.modifiers=_,this.children=L,this.isConstructor=O===E.CONSTRUCTOR}}class d{node;name;superClass=null;instanceFields;instanceMethods;staticFields;staticMethods;constructorMethod=null;nativeInstance=null;isOpen=!1;constructor(O,I,U,_,L,W,$,H=null){this.node=O,this.superClass=I,this.name=U,this.instanceFields=_,this.instanceMethods=L,this.staticFields=W,this.staticMethods=$,this.constructorMethod=H,this.isOpen=O.modifiers.open}static fromAST(O){let I=[],U={},_=[],L={},W=null;for(let $ of O.children)if($ instanceof s){let H=new DI($.name,$.fieldType?$.fieldType.name:null,$.modifiers,$.init);if(H.modifiers.static)_.push(H);else I.push(H)}else if($ instanceof T){let H=new yI($.name,$.parameters,$.returnType,$.modifiers,$.children);if(H.isConstructor)W=H;else if(H.modifiers.static)L[H.name]=H;else U[H.name]=H}else X(`Unhandled node ${$.type}.`);return new d(O,O.superClass?.name||null,O.name,I,U,_,L,W)}findMethodNode(O){let I=this.node.children.find((U)=>U.name===O);if(I instanceof T)return I;X(`Method ${O} not found in class ${this.name}.`)}findInstanceFieldDefinition(O){let I=this.instanceFields.find((U)=>U.name===O);if(I instanceof DI)return I;X(`Field ${O} not found in class ${this.name}.`)}constructEmptyInstance(O){let I=new IO(this);return O.instances.register(I),I}constructNativeInstance(O,I=[]){let U=this.constructEmptyInstance(O);return U.__nativeInstance=new this.nativeInstance(...I),U}constructNewInstanceWithoutArguments(O,I,U){return this.constructNewInstance([],O,I,U)}constructNewInstance(O,I,U,_){let L=new o(O,new u(u.KIND_SIMPLE,this.name));return this.constructInstanceByNewNode(L,I,U,_)}constructInstanceByNewNode(O,I,U,_){let L=this.constructEmptyInstance(I);if(L.initializeInstanceFields(I,U,_),!this.constructorMethod)return L;let W=this.constructorMethod,$=new x(U),H=bO(O,W.parameters,I,U,_,L);$.define(E.THIS,L);for(let Q=0;Q<H.length;Q++){let f=W.parameters[Q];if(f)$.define(f.name,H[Q])}for(let Q of W.children)zO(Q,I,$,_,L);return L}constructNativeInstanceByNewNode(O,I,U,_){let L=this.constructEmptyInstance(I),W=this.constructorMethod,$=new x(U),H=bO(O,W?W.parameters:[],I,U,_,L);if($.define(E.THIS,L),this.nativeInstance===null)X("Class has no native instance");let Q=new this.nativeInstance(...H.map(OO));if(Q instanceof w)L.__nativeInstance=Q;return L}initializeInstanceFields(O,I,U,_){if(O.__fieldsInitialized)return;let L;for(let W of this.instanceFields)L=W.initializer?k(W.initializer,I,U,_):null,O.__instanceFields[W.name]=P(L,W.type);for(let W of this.staticFields)L=W.initializer?k(W.initializer,I,U,_):null,O.__staticFields[W.name]=P(L,W.type);O.__fieldsInitialized=!0}}class QO{node;name;staticFields;instanceMethods;constructor(O,I,U,_){this.node=O,this.name=I,this.staticFields=U,this.instanceMethods=_}static fromAST(O){let I=[],U={};for(let _ of O.children)if(_ instanceof s){let L=new DI(_.name,_.fieldType?_.fieldType.name:null,_.modifiers,_.init??null);I.push(L)}else if(_ instanceof T){let L=new yI(_.name,_.parameters,_.returnType,_.modifiers,_.children);U[L.name]=L}else X(`Unhandled node ${_.type}.`);return new QO(O,O.name,I,U)}}function MU(){return new u(u.KIND_SIMPLE,K.MIXED)}function R(O){let I;if(O.peek().value===E.PARENTHESES_OPEN)I=M_(O);else I=N_(O);if(O.consumeIfOperator(E.QUESTION_MARK))I.nullable=!0;return I}function dI(O){let I=[];O.expectOperator(E.LESS_THAN);do{let U=O.expectIdentifier().value;if(I.push(U),O.peek().value!==E.COMMA)break;O.next()}while(!0);return O.expectOperator(E.GREATER_THAN),I}function N_(O){let I=O.expectIdentifier(),U=new u(u.KIND_SIMPLE,I.value);if(O.consumeIfOperator(E.LESS_THAN)){U.kind=u.KIND_GENERIC;do U.typeArguments.push(R(O));while(O.consumeIfPunctuation(E.COMMA));O.expectOperator(E.GREATER_THAN)}return U}function M_(O){let I=new u(u.KIND_LAMBDA,"lambda");if(O.expectPunctuation(E.PARENTHESES_OPEN),O.peek().value!==E.PARENTHESES_CLOSE)do I.parameterTypes.push(R(O));while(O.consumeIfPunctuation(E.COMMA));return O.expectPunctuation(E.PARENTHESES_CLOSE),O.expectOperator(E.ARROW),I.returnType=R(O),I}function bU(O){let I=[];while(O.peek().type!==Z.EOF)if(O.peek().type===Z.COMMENT)O.next();else{let U=nI(O);if(U)I.push(U)}return new q(z.PROGRAMM,I)}function nI(O){if(O.consumeIfComment())return null;switch(O.peek().value){case E.IMPORT:return v_(O);case E.OPEN:case E.CLASS:return A_(O);case E.INTERFACE:return c_(O);case E.RETURN:return b_(O);case E.LET:return m_(O);case E.IF:return TU(O);case E.MATCH:return l_(O);case E.FOREACH:return y_(O);default:return n_(O)}}function b_(O){O.expectKeyword(E.RETURN);let I=null;if(O.peek().value!==E.SEMICOLON)I=g(O);return O.expectPunctuation(E.SEMICOLON),new r(I)}function v_(O){O.expectKeyword(E.IMPORT);let I=[],U=null;if(O.peek().value===E.BRACE_OPEN)I=T_(O),O.expectKeyword(E.FROM),U=O.expectString().value;else I.push(O.expectIdentifier().value);return O.expectPunctuation(E.SEMICOLON),new YO(I,U)}function T_(O){O.expectPunctuation(E.BRACE_OPEN);let I=[];while(!0){let U=O.expectIdentifier();if(I.push(U.value),O.consumeIfPunctuation(E.COMMA))continue;break}return O.expectPunctuation(E.BRACE_CLOSE),I}function A_(O){let I=tI(O),U=aI(O,[E.OPEN]),_=O.expectKeyword(E.CLASS),L=O.expectIdentifier(),W=[];if(O.peek().value===E.LESS_THAN)W=dI(O);let $=null;if(O.consumeIfKeyword(E.EXTENDS))$=new sI(z.IDENTIFIER,O.expectIdentifier().value);let H=[];if(O.peek().value===E.IMPLEMENTS){O.next();do{let B=R(O);H.push(B)}while(O.consumeIfPunctuation(E.COMMA))}O.expectPunctuation(E.BRACE_OPEN);let Q=[];while(O.peek().value!==E.BRACE_CLOSE){if(O.peek().type===Z.COMMENT){O.next();continue}let B=vU(O);if(B===null)continue;Q.push(B)}let f=O.expectPunctuation(E.BRACE_CLOSE),Y=new v(L.value,I,U,W,H,$,Q);return Y.span=N(_,f),Y}function c_(O){let I=tI(O),U=aI(O,[]),_=O.expectKeyword(E.INTERFACE),L=O.expectIdentifier(),W=[];if(O.peek().value===E.LESS_THAN)W=dI(O);let $=[];if(O.consumeIfKeyword(E.EXTENDS))do $.push(O.expectIdentifier().value);while(O.consumeIfPunctuation(E.COMMA));O.expectPunctuation(E.BRACE_OPEN);let H=[];while(O.peek().value!==E.BRACE_CLOSE){if(O.consumeIfComment())continue;let Y=vU(O);if(Y===null)continue;if(Y instanceof s&&!Y.modifiers.static)G("Interface fields must be static.");if(Y instanceof T&&Y.children.length>0)G("Interface methods must not have a body.");H.push(Y)}let Q=O.expectPunctuation(E.BRACE_CLOSE),f=new KO(L.value,I,U,W,$,H);return f.span=N(_,Q),f}function tI(O){let I=[];while(O.peek().type===Z.ANNOTATION)I.push(R_(O));return I}function R_(O){let I=O.expectAnnotation(),U=new VI(I.value);if(O.consumeIfPunctuation(E.PARENTHESES_OPEN)){while(O.peek().value!==E.PARENTHESES_CLOSE){let _=O.expectIdentifier().value;O.expectOperator(E.ASSIGN);let L=g(O);if(U.properties.set(_,L),O.peek().value===E.COMMA)O.next()}O.expectPunctuation(E.PARENTHESES_CLOSE)}return U}function aI(O,I){let U={};I.forEach((_)=>U[_]=!1);while(O.peek().type===Z.KEYWORD&&I.includes(O.peek().value)){let _=O.next().value;if(U[_])G(`Duplicate modifier: ${_}`);U[_]=!0}return new lI(U)}function i_(O){let I=[];if(O.peek().value===E.PARENTHESES_CLOSE)return I;do{let U=O.expectIdentifier(),_=null,L=null,W=null,$=null;if(O.peek().value===E.COLON)W=O.next(),_=R(O);if(O.peek().value===E.ASSIGN)$=O.next(),L=g(O);let H=new PO(U.value,_,L);H.span=N(W||U,$||U),I.push(H)}while(O.consumeIfPunctuation(E.COMMA));return I}function vU(O){let I=O.peek(),U=tI(O),_=aI(O,[E.PUBLIC,E.PRIVATE,E.STATIC,E.READONLY]),L=O.expectOneOf([Z.IDENTIFIER,Z.KEYWORD]),W=null;if(O.peek().value===E.COLON){if(O.consumeIfPunctuation(E.COLON))W=R(O)}let $=null;if(O.consumeIfOperator(E.ASSIGN))$=g(O);if(O.peek().value===E.SEMICOLON){if(!_.public&&!_.private)_.private=!0;let Q=O.expectPunctuation(E.SEMICOLON),f=new s(L.value,_,W,$);return f.span=N(I,Q),f}let H=[];if(O.peek().value===E.LESS_THAN)H=dI(O);if(O.peek().value===E.PARENTHESES_OPEN){if(!_.public&&!_.private)_.public=!0;O.expectPunctuation(E.PARENTHESES_OPEN);let Q=i_(O),f=O.expectPunctuation(E.PARENTHESES_CLOSE),Y=null;if(O.consumeIfPunctuation(E.COLON))Y=R(O);let B=vO(O),b=new T(L.value,L.value===E.CONSTRUCTOR?z.CONSTRUCTOR:z.METHOD,U,_,H,Q,Y,B);return b.span=N(I,f),b}return G(`Invalid class member: ${L.value}`),null}function vO(O){if(O.peek().value===E.SEMICOLON)return O.next(),[];O.expectPunctuation(E.BRACE_OPEN);let I=[];while(O.peek().value!==E.BRACE_CLOSE){if(O.peek().type===Z.COMMENT){O.next();continue}let U=nI(O);if(U)I.push(U)}return O.expectPunctuation(E.BRACE_CLOSE),I}function m_(O){let I=O.expectKeyword(E.LET),U=O.expectIdentifier(),_=null;if(O.consumeIfPunctuation(E.COLON))_=R(O);let L=null;if(O.peek().value===E.ASSIGN)O.expectOperator(E.ASSIGN),L=g(O);let W=O.expectPunctuation(E.SEMICOLON),$=new ZO(U.value,_,L);return $.span=N(I,W),$}function TU(O){let I=O.expectKeyword(E.IF);O.expectPunctuation(E.PARENTHESES_OPEN);let U=g(O),_=O.expectPunctuation(E.PARENTHESES_CLOSE),L=new VO(U,new GI(vO(O)));if(O.consumeIfKeyword(E.ELSE))if(O.peek().value===E.IF)L.else=TU(O);else L.else=new hI(vO(O));return L.span=N(I,_),L}function l_(O){let I=O.expectKeyword(E.MATCH);O.expectPunctuation(E.PARENTHESES_OPEN);let U=g(O);O.expectPunctuation(E.PARENTHESES_CLOSE),O.expectPunctuation(E.BRACE_OPEN);let _=[],L=null;while(O.peek().value!==E.BRACE_CLOSE){let H=s_(O);if(H.test===null){L=H;continue}_.push(H)}let W=O.expectPunctuation(E.BRACE_CLOSE),$=new AO(U,_,L);return $.span=N(I,W),$}function s_(O){let I=new jI;if(O.consumeIfKeyword(E.DEFAULT))I.test=null;else I.test=g(O);if(O.expectPunctuation(E.COLON),O.peek().value===E.BRACE_OPEN)I.children=vO(O);else{let U=nI(O);if(U)I.children.push(U)}return I}function y_(O){let I=O.expectKeyword(E.FOREACH);O.expectPunctuation(E.PARENTHESES_OPEN);let _=O.expectIdentifier().value;O.expectKeyword(E.IN);let L=g(O),W=O.expectPunctuation(E.PARENTHESES_CLOSE),$=new CO(_,L,vO(O));return $.span=N(I,W),$}function d_(O){let I=O.expectPunctuation(E.BRACKET_SQUARE_OPEN),U=new m;if(O.peek().value!==E.BRACKET_SQUARE_CLOSE)do U.elements.push(g(O));while(O.consumeIfPunctuation(E.COMMA));let _=O.expectPunctuation(E.BRACKET_SQUARE_CLOSE);return U.span=N(I,_),U}function AU(O){let I=O.expectPunctuation(E.BRACE_OPEN),U=[];while(O.peek().value!==E.ARROW){let H=O.expectIdentifier().value,Q=null,f=null;if(O.consumeIfPunctuation(E.COLON))Q=R(O);if(O.peek().value===E.ASSIGN)O.next(),f=g(O);U.push(new PO(H,Q,f)),O.consumeIfPunctuation(E.COMMA)}O.expectOperator(E.ARROW);let _=MU();if(O.peek().type===Z.IDENTIFIER)if(_=R(O),O.peek().value===E.COLON)O.next();else _=MU(),O.rewind();let L=[];if(O.peek().value===E.BRACE_OPEN)L=vO(O);else L.push(g(O));let W=O.expectPunctuation(E.BRACE_CLOSE),$=new l(U,_,L);return $.span=N(I,W),$}function cU(O){let I=O.position();if(O.peek().value!==E.BRACE_OPEN)return!1;O.next();while(O.peek().type===Z.IDENTIFIER){if(O.next(),O.consumeIfPunctuation(E.COLON))O.next();if(!O.consumeIfPunctuation(E.COMMA))break}let U=O.peek().value===E.ARROW;return O.seekAt(I),U}function n_(O){let I=g(O);return O.expectPunctuation(E.SEMICOLON),new qO(I)}function g(O,I=0){let U=o_(O,mU(O));while(!0){let _=O.peek();if(!_)break;let L=r_(_);if(L<I)break;if(_.value===E.ASSIGN){O.next(),U=new TO(U,g(O,L));continue}if(E.MATH_OPERATORS.includes(_.value)||E.LOGIC_OPERATORS.includes(_.value)){let W=O.next(),$=g(O,L+1),H=O.peek(),Q=new BO(U,$,_.value);Q.span=N(W,H),U=Q;continue}break}return U}function t_(O){return O.expectKeyword(E.VDOM),RU(O)}function RU(O){O.consumeIfText();let I=O.expectOperator(E.LESS_THAN),_=O.expectIdentifier().value;O.consumeIfText();let L=new Map;while(!0){if(O.peekIs(E.GREATER_THAN))break;if(O.peekIs(E.XML_CLOSE_TAG))break;let H=O.expectIdentifier();O.expectOperator(E.ASSIGN);let Q;if(O.peekIs(E.BRACE_OPEN))if(cU(O))Q=AU(O);else O.next(),Q=g(O),O.expectPunctuation(E.BRACE_CLOSE);else Q=g(O);L.set(H.value,Q),O.consumeIfText()}O.expectOperator(E.GREATER_THAN);let W=[];while(!O.peekIs(E.XML_OPEN_CLOSE_TAG)){if(O.peek().type===Z.OPERATOR){W.push(RU(O));continue}W.push(a_(O))}O.expectOperator(E.XML_OPEN_CLOSE_TAG),O.expectIdentifier(),O.expectOperator(E.GREATER_THAN);let $=new _O(_,L,W);return $.span=N(I,O.peek()),$}function a_(O){let I=O.expectOneOf([Z.IDENTIFIER,Z.OPERATOR,Z.KEYWORD,Z.PUNCTUATION,Z.TEXT]),U=new cO(I.value);return U.span=N(I,I),U}function iU(O){let I=[];if(O.consumeIfPunctuation(E.PARENTHESES_CLOSE))return I;I.push(g(O));while(O.consumeIfPunctuation(E.COMMA))I.push(g(O));return O.expectPunctuation(E.PARENTHESES_CLOSE),I}function mU(O){let I=O.peek();if(I.type===Z.KEYWORD&&I.value===E.VDOM)return t_(O);if(I.value===E.EXCLAMATION_MARK){O.next();let U=mU(O);return new JO(E.EXCLAMATION_MARK,U)}return p_(O)}function p_(O){if(cU(O))return AU(O);let I=O.next();if(I.value===E.BRACKET_SQUARE_OPEN)return O.rewind(),d_(O);if(I.type===Z.NUMBER){let U=new q(z.NUMBER);return U.value=I.value,U}if(I.type===Z.STRING){let U=new q(z.STRING);return U.value=I.value,U}if(I.type===Z.BOOLEAN){let U=new q(z.BOOLEAN);return U.value=I.value,U}if(I.type===Z.IDENTIFIER){let U=new q(z.IDENTIFIER);return U.name=I.value,U}if(I.value===E.NULL){let U=new q(z.NULL);return U.value=I.value,U}if(I.value===E.THIS){let U=new q(z.THIS);return U.name=I.value,U}if(I.value===E.NEW){let U=R(O);return O.expectPunctuation(E.PARENTHESES_OPEN),new o(iU(O),U)}if(I.value===E.PARENTHESES_OPEN){let U=g(O);return O.expectPunctuation(E.PARENTHESES_CLOSE),U}G(`Unexpected token: ${I.type} ${I.value}`)}function o_(O,I){if(I===null)G("Expected expression, got null.");while(!0){let U=O.peek();if(!U)break;if(U.value===E.PARENTHESES_OPEN){O.next(),I=new p(I,iU(O));continue}if(U.value===E.DOT){O.next(),I=new S(I,O.expectIdentifier().value);continue}if(U.value===E.BRACKET_SQUARE_OPEN){O.next();let _=g(O);O.expectPunctuation(E.BRACKET_SQUARE_CLOSE),I=new fO(I,_);continue}break}return I}function r_(O){switch(O.value){case E.DOT:return 100;case E.PARENTHESES_OPEN:return 90;case E.MULTIPLY:case E.DIVIDE:case E.MODULUS:return 60;case E.PLUS:case E.MINUS:return 50;case E.LESS_THAN:case E.GREATER_THAN:case E.LESS_EQUAL:case E.GREATER_EQUAL:return 40;case E.EQUAL:case E.NOT_EQUAL:return 30;case E.AND:return 20;case E.OR:return 10;case E.ASSIGN:return 5;default:return 0}}class n{source;tokenStream=null;constructor(O){this.source=O}parse(){return this.tokenStream=this.source.getTokenizer().getTokenStream(),bU(this)}stream(){if(!this.tokenStream)G("Parser has not been parsed yet.");return this.tokenStream}expect(O,I=null){let U=this.stream().next();if(!U)G(`Unexpected end of file. Expected ${O}${I?" "+I:""}`);if(U.type!==O||I&&U.value!==I)G(`Expected ${O}${I?" "+I:""}, got ${U.type} ${U.value}`);return U}expectOperator(O=null){return this.expect(Z.OPERATOR,O)}expectAnnotation(){return this.expect(Z.ANNOTATION)}expectIdentifier(O=null){return this.expect(Z.IDENTIFIER,O)}expectKeyword(O=null){return this.expect(Z.KEYWORD,O)}expectString(){return this.expect(Z.STRING)}expectText(){return this.expect(Z.TEXT)}expectPunctuation(O=null){return this.expect(Z.PUNCTUATION,O)}expectOneOf(O,I=null){let U=this.stream().next();if(!U)G(`Unexpected end of file. Expected one of types ${O}, got null.`);if(!O.includes(U.type))G(`Expected one of types ${O}, got ${U.type}`);if(I&&!I.includes(U.value))G(`Expected one of values ${I}, got ${U.value}`);return U}consumeIf(O,I=null){let U=this.peek();if(U.type===O&&(I&&U.value.trim()===I))return this.next(),!0;return!1}consumeIfPunctuation(O){return this.consumeIf(Z.PUNCTUATION,O)}consumeIfOperator(O){return this.consumeIf(Z.OPERATOR,O)}consumeIfComment(){return this.consumeIf(Z.COMMENT)}consumeIfKeyword(O){return this.consumeIf(Z.KEYWORD,O)}consumeIfText(){if(this.peek().type===Z.TEXT&&this.peekIs(""))return this.next(),!0;return!1}peek(){let O=this.stream().peek();if(O===null)G("Unexpected end of file. Expected token, got null.");return O}peekIs(O){return this.peek().value.trim()===O}next(){let O=this.stream().next();if(O===null)G("Unexpected end of file. Expected token, got null.");return O}rewind(){this.stream().rewind()}position(){return this.stream().index}seekAt(O){this.stream().index=O}}class lU{map=new Map;register(O){this.set(O.name,d.fromAST(O))}all(){return this.map.values()}set(O,I){this.map.set(O,I)}get(O){let I=this.map.get(O)||null;if(!I)X(`Class ${O} not found.`);return I}has(O){return this.map.has(O)}}class sU{map=new Map;register(O){this.set(O.name,QO.fromAST(O))}all(){return this.map.values()}set(O,I){this.map.set(O,I)}}class yU{instances=new Map;register(O){this.instances.set(O.id,O)}unregister(O){this.instances.delete(O.id)}get(O){return this.instances.get(O)||null}allInstances(){return Array.from(this.instances.values())}}class dU{classSymbols=new Map;interfaceSymbols=new Map;allClassSymbols(){return this.classSymbols.values()}allInterfaceSymbols(){return this.interfaceSymbols.values()}addClassSymbol(O){this.classSymbols.set(O.name,O)}addInterfaceSymbol(O){this.interfaceSymbols.set(O.name,O)}hasSymbol(O){return this.classSymbols.has(O)||this.interfaceSymbols.has(O)}getClassSymbol(O){let I=this.classSymbols.get(O);if(I===void 0)X(`Symbol ${O} not found.`);return I}getInteraceSymbol(O){let I=this.interfaceSymbols.get(O);if(I===void 0)X(`Symbol ${O} not found.`);return I}}class oO{classes=new lU;interfaces=new sU;instances=new yU;types=new dU;fetchAllObjectDefinitions(){let O=new Map;for(let I of this.interfaces.all())O.set(I.name,I);for(let I of this.classes.all())O.set(I.name,I);return O}collectAll(O){for(let I of O.children)if(I instanceof KO)this.interfaces.register(I);else if(I instanceof v)this.classes.register(I)}}var nU=new wO().getGlobalFunctionTypeRegistry();class XO{didReturn;returnType;constructor(O,I){this.didReturn=O,this.returnType=I}static withReturn(O){return new XO(!0,O)}static noReturn(){return new XO(!1,null)}}class pI{objectRegistry;constructor(O){this.objectRegistry=O}collectAllSymbolsFromNode(O){for(let I of O.children)if(I instanceof KO)this.registerInterfaceSymbol(I);else if(I instanceof v)this.registerClassSymbol(I)}collectAllSymbolsFromRegistry(O){let I=O.fetchAllObjectDefinitions().values();for(let U of I)if(U instanceof QO)this.registerInterfaceSymbol(U.node);else this.registerClassSymbol(U.node)}check(O){this.collectAllSymbolsFromNode(O),this.validateInheritance(),this.checkProgram(O),this.checkInterfaceBodies(),this.checkClassesBodies(),this.checkClassesImplements()}validateInheritance(){for(let O of this.objectRegistry.classes.all())if(O.superClass&&!this.objectRegistry.types.hasSymbol(O.superClass))this.typeError(`Unknown superclass ${O.superClass}`,O.node)}checkProgram(O){let I=new V;for(let U of O.children)this.checkStatement(U,I)}checkClassesBodies(){for(let O of this.objectRegistry.types.allClassSymbols()){let I=new V;if(I.currentObjectSymbol=O,O.typeParameterSymbols.forEach((U)=>{I.defineTypeBinding(U.name,new j(U.name))}),O.constructorMethodSymbol){let U=O.constructorMethodSymbol,_=new V(I);O.typeParameterSymbols.forEach((L)=>{_.defineTypeBinding(L.name,new j(L.name))});for(let L of U.parameterSymbols)_.defineType(L.name,L.parameterType);this.checkBody(U.body,_)}for(let U of O.instanceMethodSymbols.values()){let _=new V(I);U.typeParameterSymbols.forEach((W)=>{_.defineTypeBinding(W.name,new j(W.name))});for(let W of U.parameterSymbols)_.defineType(W.name,W.parameterType);if(U.body&&U.body.length>0){let W=this.checkBody(U.body,_);this.checkReturnType(U.returnType,W,U.node)}}for(let U of O.staticMethodSymbols.values()){let _=new V(I);U.typeParameterSymbols.forEach((W)=>{_.defineTypeBinding(W.name,new j(W.name))});for(let W of U.parameterSymbols)_.defineType(W.name,W.parameterType);if(U.body&&U.body.length>0){let W=this.checkBody(U.body,_);this.checkReturnType(U.returnType,W,U.node)}}}}checkInterfaceBodies(){for(let O of this.objectRegistry.types.allInterfaceSymbols()){let I=new V;I.currentObjectSymbol=O,O.typeParameterSymbols.forEach((U)=>{I.defineTypeBinding(U.name,new j(U.name))});for(let U of O.instanceMethodSymbols.values()){let _=new V(I);U.typeParameterSymbols.forEach((W)=>{_.defineTypeBinding(W.name,new j(W.name))});for(let W of U.parameterSymbols)_.defineType(W.name,W.parameterType);if(U.body&&U.body.length>0){let W=this.checkBody(U.body,_);this.checkReturnType(U.returnType,W,U.node)}}}}checkClassesImplements(){for(let O of this.objectRegistry.types.allClassSymbols())for(let I of O.implementsInterfaces)this.checkImplementsInterface(O,I)}checkImplementsInterface(O,I){let U=I.interfaceSymbol,_=vI(U.typeParameterSymbols,I.typeArguments);for(let L of U.instanceMethodSymbols.values()){let W=this.resolveInstanceMethode(O,L.name);if(!W)this.typeError(`Class ${O.name} does not implement method ${L.name} from interface ${U.name}`,O.node);this.checkMethodCompatibility(W,L,_)}}checkMethodCompatibility(O,I,U){if(O.parameterSymbols.length!==I.parameterSymbols.length)this.typeError(`Method ${O.name} has wrong parameter count`);for(let L=0;L<I.parameterSymbols.length;L++){let W=I.parameterSymbols[L]||null;if(!W){this.typeError(`Method ${O.name} has too many parameters`);break}let $=DO(W.parameterType,U),H=W.parameterType;if(!$.accepts(H))this.typeError(`Parameter ${L+1} of ${O.name} incompatible with interface`)}if(!DO(I.returnType,U).accepts(O.returnType))this.typeError(`Return type of ${O.name} incompatible with interface`)}checkStatement(O,I){switch(O.type){case z.RETURN:if(O instanceof r)return XO.withReturn(this.checkExpression(O.argument,I));break;case z.VARIABLE:if(O instanceof ZO)return this.checkVariable(O,I),XO.noReturn();break;case z.FOREACH:if(O instanceof CO)return XO.withReturn(this.checkForeach(O,I));break;case z.EXPRESSION:if(O instanceof qO)return this.checkExpression(O.expr,I),XO.noReturn();break}return XO.noReturn()}checkVariable(O,I){let U=O.typeAnnotation?this.wrapType(O.typeAnnotation,I):null,_=this.checkExpression(O.init,I,U);if(U&&!U.accepts(_))this.typeError(`Type mismatch: ${U} <> ${_}`,O);I.defineType(O.name,U??_)}checkForeach(O,I){let U=this.checkExpression(O.iterable,I);if(U=nO.autoboxIfNeeded(U,this.objectRegistry),U instanceof D&&U.classSymbol.name==="Array"){if(U.typeArguments.length!==1)this.typeError("Array in foreach musst have exactly one type argument.",O.iterable);let _=U.typeArguments[0]||null;if(_===null)this.typeError("Array in foreach must have exactly one type argument.",O.iterable);let L=new V(I);return L.defineType(O.iterator,_),this.checkBody(O.body,L)}this.typeError(`foreach expects Array<T>, got ${U.toString()}`,O.iterable)}checkExpression(O,I,U=null){if(O===null)this.typeError("Expression expected, got null.",O);switch(O.type){case z.NUMBER:return J.NUMBER;case z.STRING:return J.STRING;case z.BOOLEAN:return J.BOOLEAN;case z.NULL:return J.NULL;case z.VDOM:{if(O instanceof _O)return this.checkVDomNode(O);break}case z.ARRAY:{if(O instanceof m)return this.checkArrayExpression(O,I,U);break}case z.INDEX:{if(O instanceof fO){let _=this.checkExpression(O.object,I),L=this.checkExpression(O.index,I);if(_ instanceof D)return _.typeArguments[0]||J.MIXED;this.typeError(`Cannot index ${_.name} with ${L.name}`,O)}break}case z.UNARY:{if(O instanceof JO)return this.checkUnaryExpression(O,I);break}case z.MEMBER:{if(O instanceof S)return this.checkMemberExpression(O,I);break}case z.THIS:return this.checkThisExpression(O,I);case z.IDENTIFIER:return this.checkIdentifierExpression(O,I);case z.NEW:{if(O instanceof o)return this.checkNewExpression(O,I,U);break}case z.BINARY:{if(O instanceof BO)return this.checkBinaryExpression(O,I);break}case z.LAMBDA:{if(O instanceof l)return this.checkLambdaExpression(O,I);break}case z.CALL:{if(O instanceof p)return this.checkCallExpression(O,I);break}}return J.MIXED}checkBinaryExpression(O,I){let U=this.checkExpression(O.left,I),_=this.checkExpression(O.right,I),L=O.operator;if(E.ARITHMETIC.includes(L)){if(U.accepts(J.NUMBER)&&_.accepts(J.NUMBER))return J.NUMBER;if(U.accepts(J.STRING)||_.accepts(J.STRING))return J.STRING;this.typeError(`Arithmetic operator '${L}' requires numbers`,O)}if(E.COMPARISON.includes(L)){if(U.accepts(J.NUMBER)&&_.accepts(J.NUMBER))return J.BOOLEAN;this.typeError(`Comparison '${L}' requires numbers`,O)}if(E.EQUALITY.includes(L)){if(U.accepts(_))return J.BOOLEAN;this.typeError(`Cannot compare ${U.name} with ${_.name}`,O)}if(E.LOGICAL.includes(L)){if(U.accepts(J.BOOLEAN)&&_.accepts(J.BOOLEAN))return J.BOOLEAN;this.typeError(`Logical operator '${L}' requires booleans`,O)}this.typeError("Invalid binary operation",O)}checkFieldAccess(O,I,U,_){if(U.isPublic)return;if(!_.currentObjectSymbol)this.typeError(`Cannot access private member ${O.property} of ${I.name}`,O);if(_.currentObjectSymbol!==U.owner){if(_.currentObjectSymbol instanceof $O&&_.currentObjectSymbol.superClassSymbol!==U.owner)this.typeError(`Cannot access private member ${O.property} of ${I.name}`,O)}}checkInstanceMethodAccess(O,I,U,_){if(U.isPublic)return;if(!_.currentObjectSymbol)this.typeError(`Cannot access private method ${O.property} of ${I.name}`,O);if(_.currentObjectSymbol!==U.owner){if(_.currentObjectSymbol instanceof $O&&_.currentObjectSymbol.superClassSymbol!==U.owner)this.typeError(`Cannot access private method ${O.property} of ${I.name}`,O)}}checkStaticMethodAccess(O,I,U){if(!I.isStatic){this.typeError(`Cannot call instance method ${O.name}.${I.name} as static method`);return}if(I.isPublic)return;if(!U.currentObjectSymbol)this.typeError(`Cannot access private method ${I.name} of ${O.name}`,I.node);if(U.currentObjectSymbol!==I.owner){if(U.currentObjectSymbol instanceof $O&&U.currentObjectSymbol.superClassSymbol!==I.owner)this.typeError(`Cannot access private method ${I.name} of ${O.name}`,I.node)}}checkMemberExpression(O,I){let U=this.checkExpression(O.object,I);if(U instanceof D){let _=U.classSymbol,L=_.resolveInstanceFieldSymbol(O.property);if(L)return this.checkFieldAccess(O,_,L,I),L.fieldType;let W=_.resolveStaticFieldSymbol(O.property);if(W)return this.checkFieldAccess(O,_,W,I),W.fieldType;this.typeError(`Unknown member ${O.property}`,O)}this.typeError("Cannot access member of non-object",O)}checkThisExpression(O,I){if(I.currentObjectSymbol instanceof $O)return new D(I.currentObjectSymbol);this.typeError("this outside of class",O)}checkIdentifierExpression(O,I){if(I.hasType(O.name))return I.getType(O.name);if(this.objectRegistry.types.hasSymbol(O.name))return new D(this.objectRegistry.types.getClassSymbol(O.name));this.typeError(`Undefined identifier ${O.name}`,O)}checkNewExpression(O,I,U=null){let _=this.objectRegistry.types.getClassSymbol(O.name),L;if(O.typeAnnotation.typeArguments.length>0){let W=O.typeAnnotation.typeArguments.map(($)=>this.wrapType($,I));if(W.length!==_.typeParameterSymbols.length)this.typeError("Wrong number of type arguments",O);L=new D(_,W)}else if(U instanceof D)L=U;else L=new D(_,_.typeParameterSymbols.map(()=>J.MIXED));if(_.constructorMethodSymbol)this.checkCallArguments(_.constructorMethodSymbol,O.arguments,I);if(U&&!U.accepts(L))this.typeError(`Type mismatch: ${U} <> ${L}`,O);return L}checkArrayExpression(O,I,U=null){if(O.elements.length===0){if(U instanceof D)U=U.typeArguments[0]||null;return this.newArrayTypeOf(U||J.MIXED)}let _=gO.getClassRefName(gO.ARRAY),L;if(U instanceof D&&U.classSymbol.name===_)L=U.typeArguments[0]||J.MIXED;else if(O.elements[0])L=this.checkExpression(O.elements[0],I,U);else this.typeError("Array expression must have at least one element",O);for(let W of O.elements){let $=this.checkExpression(W,I,L);if(!L.accepts($))this.typeError(`Array elements must have same type, got ${L} and ${$}`,O)}return this.newArrayTypeOf(L)}checkUnaryExpression(O,I){let U=this.checkExpression(O.argument,I),_=O.operator;if(_===E.EXCLAMATION_MARK){if(U.equals(J.BOOLEAN))return J.BOOLEAN;this.typeError(`Unary '!' requires boolean, got ${U.name}`,O)}this.typeError(`Invalid unary operator ${_}`,O)}checkLambdaExpression(O,I){let U=new V(I),_=O.parameters.map((L)=>{let W=this.parameterNodeToSymbol(L);return U.defineType(L.name,W.parameterType),W});if(O.children[0])return new FO(_,this.checkExpression(O.children[0],U));this.typeError("Lambda expression must have a return type",O)}checkCallExpression(O,I){let U=O.callee;if(U.type===z.IDENTIFIER&&U.name===E.SUPER)return this.checkSuperConstructorCall(O,I);if(U instanceof S&&U.object.type===z.IDENTIFIER&&this.objectRegistry.types.hasSymbol(U.object.name))return this.checkStaticCall(U.object.name,U.property,O.arguments,I);if(U instanceof S)return this.checkInstanceCall(U,O.arguments,I);if(U instanceof l)return this.checkLambdaCall(this.checkLambdaExpression(U,I),O.arguments,I);if(U.type===z.IDENTIFIER){if(I.hasType(U.name)){let _=I.getType(U.name);if(_ instanceof FO)return this.checkLambdaCall(_,O.arguments,I);this.typeError(`Cannot call non-function ${U.name}`,O)}return this.checkFunctionCall(U.name,O.arguments,I)}return J.MIXED}checkSuperConstructorCall(O,I){let U=I.currentObjectSymbol;if(!(U instanceof $O))this.typeError("super() used outside of class",O);if(!U.superClass)this.typeError("super() used outside of class hierarchy",O);let _=this.objectRegistry.types.getClassSymbol(U.superClass);if(!_.constructorMethodSymbol){if(O.arguments.length>0)this.typeError("Super constructor takes no arguments",O);return J.VOID}return this.checkCallArguments(_.constructorMethodSymbol,O.arguments,I),J.VOID}checkCallOnNullObjectType(O,I){if(O.equals(J.NULL))this.typeError("Cannot call method on null",I);if(O instanceof UO)this.typeError(`Cannot call method on nullable type ${O}`,I)}checkInstanceCall(O,I,U){let _=this.checkExpression(O.object,U);if(_=nO.autoboxIfNeeded(_,this.objectRegistry),this.checkCallOnNullObjectType(_,O),_ instanceof D){let L=this.resolveInstanceMethode(_.classSymbol,O.property);if(L.isStatic)this.typeError(`Cannot call static method ${O.property} on instance of ${O.object.name}`,O);this.checkInstanceMethodAccess(O,_.classSymbol,L,U);let W=L.owner;if(W===null)this.typeError("Cannot call method on non-object",O);let $=vI(W.typeParameterSymbols,_.typeArguments);return this.checkCallArguments(L,I,U,$),DO(L.returnType,$)}this.typeError("Cannot call method on non-object",O)}checkStaticCall(O,I,U,_){let L=this.objectRegistry.types.getClassSymbol(O),W=L.staticMethodSymbols.get(I)||null;if(!W)this.typeError(`Unknown static method ${O}.${I}`);return this.checkStaticMethodAccess(L,W,_),this.checkCallArguments(W,U,_),W.returnType}checkLambdaCall(O,I,U){return this.checkCallArguments(O,I,U),O.returnType}checkFunctionCall(O,I,U){if(!nU.has(O))this.typeError(`Unknown function ${O}`);let _=nU.get(O);return this.checkCallArguments(_,I,U),_.returnType?this.wrapType(_.returnType,U):J.VOID}parametersSymbolsFromCallableSymbol(O){if(O instanceof ZI)return O.parameterNodes.map((I)=>this.parameterNodeToSymbol(I));return O.parameterSymbols}checkCallArguments(O,I,U,_=new Map){let L=new V(U),W=this.parametersSymbolsFromCallableSymbol(O);if(I.length>W.length)this.typeError("Argument count mismatch");let $;for(let H=0;H<W.length;H++){let Q=W[H]||null,f=I[H]||null;if(Q){let Y=DO(Q.parameterType,_);if(f)$=this.checkExpression(f,L,Y);else if(Q.defaultType)$=Q.defaultType;else this.typeError(`Missing argument ${Q.name}`,f);this.checkAssignable(Y,$,I[H])}}}checkAssignable(O,I,U=null){if(O.equals(I))return;if(O instanceof dO)return;if(O instanceof UO){if(I===J.NULL)return;if(O.inner.accepts(I))return}if(O.accepts(I))return;this.typeError(`Type mismatch: ${O} <> ${I}`,U)}checkBody(O,I){let U=J.MIXED;for(let _ of O){let L=this.checkStatement(_,I);if(L.didReturn&&L.returnType)U=L.returnType}return U}checkReturnType(O,I,U){if(O===J.VOID){if(I!==J.MIXED&&I!==J.VOID)this.typeError(`Cannot return ${I} from void method`,U);return}if(I===J.MIXED)this.typeError(`Missing return statement (expected ${O})`,U);if(!O.accepts(I))this.typeError(`Return type mismatch: expected ${O}, got ${I}`,U)}checkVDomNode(O){try{let I=this.objectRegistry.types.getClassSymbol(O.tag),U=this.resolveInstanceMethode(I,"render");if(!U)this.typeError(`Component '${O.tag}' has no render() method`,O);return this.checkAssignable(U.returnType,J.VNODE,O),J.VNODE}catch(I){}return J.VNODE}resolveInstanceMethode(O,I){let U=this.resolveInHierarchy(O,(_)=>_.instanceMethodSymbols.get(I)||null);if(!U)this.typeError(`Unknown method ${O.name}.${I}`,O.node);return U}resolveInHierarchy(O,I){let U=O;while(U){let _=I(U);if(_!==void 0&&_!==null)return _;if(!U.superClass)return null;U=this.objectRegistry.types.getClassSymbol(U.superClass)}return null}newArrayTypeOf(O){let I=gO.getClassRefName(gO.ARRAY);if(I===null)this.typeError("Internal error: Cannot find class name for array type.");return new D(this.objectRegistry.types.getClassSymbol(I),[O])}wrapType(O,I){return qI(O,this.objectRegistry,I)}parameterNodeToSymbol(O,I=new V){let U=O.typeAnnotation?this.wrapType(O.typeAnnotation,I):J.MIXED,_=null;if(O.defaultValue){if(_=this.checkExpression(O.defaultValue,new V),_&&!U.equals(J.MIXED)&&!U.equals(_))this.typeError(`Default value for parameter '${O.name}' does not match type.`,O)}return new CI(O.name,U,_,O)}registerClassSymbol(O){if(this.objectRegistry.types.hasSymbol(O.name))return;let I=new V,U=new $O(O);try{if(U.superClass)U.superClassSymbol=this.objectRegistry.types.getClassSymbol(U.superClass)}catch(_){}this.objectRegistry.types.addClassSymbol(U),O.typeParameters.forEach((_)=>{U.typeParameterSymbols.push(new NO(_)),I.defineTypeBinding(_,new j(_))});for(let _ of O.implementsInterfaces){let L=this.wrapType(_,I);if(L instanceof WO){U.implementsInterfaces.push(L);continue}this.typeError(`Expected interface type, got ${L}`,_)}for(let _ of O.children){if(_.type===z.FIELD&&_ instanceof s){let L=_.modifiers.static?U.staticFieldSymbols:U.instanceFieldSymbols,W=new YI(_,_.fieldType?this.wrapType(_.fieldType,I):J.MIXED);W.owner=U,L.set(W.name,W)}if((_.type===z.METHOD||_.type===z.CONSTRUCTOR)&&_ instanceof T){let L=new V(I),W=new kI(_);if(W.owner=U,_.typeParameters.forEach(($)=>{W.typeParameterSymbols.push(new NO($)),L.defineTypeBinding($,new j($))}),W.parameterSymbols=_.parameters.map(($)=>this.parameterNodeToSymbol($,L)),W.returnType=_.returnType?this.wrapType(_.returnType,L):J.VOID,_.type===z.CONSTRUCTOR)U.constructorMethodSymbol=W;else(W.isStatic?U.staticMethodSymbols:U.instanceMethodSymbols).set(_.name,W)}}}registerInterfaceSymbol(O){if(this.objectRegistry.types.hasSymbol(O.name))return;let I=new V,U=new bI(O);this.objectRegistry.types.addInterfaceSymbol(U),O.typeParameters.forEach((_)=>{U.typeParameterSymbols.push(new NO(_)),I.defineTypeBinding(_,new j(_))});for(let _ of O.extendsInterfaces){let L=this.objectRegistry.types.getInteraceSymbol(_);L.extendsInterfaces.push(L)}for(let _ of O.children){if(_.type===z.FIELD&&_ instanceof s){let L=new YI(_,_.fieldType?this.wrapType(_.fieldType,I):J.MIXED);L.owner=U,U.staticFieldSymbols.set(L.name,L)}if(_.type===z.METHOD&&_ instanceof T){let L=new V(I),W=new kI(_);W.owner=U,_.typeParameters.forEach(($)=>{W.typeParameterSymbols.push(new NO($)),L.defineTypeBinding($,new j($))}),W.parameterSymbols=_.parameters.map(($)=>this.parameterNodeToSymbol($,L)),W.returnType=_.returnType?this.wrapType(_.returnType,L):J.VOID,U.instanceMethodSymbols.set(_.name,W)}}}typeError(O,I=null){y(O,I?.span)}}class oI{objectRegistry=new oO;names;url;ast=null;constructor(O,I){this.names=O,this.url=I}}class rI{environment;objectRegistry;fileLoader;constructor(O,I,U){this.environment=O,this.objectRegistry=I,this.fileLoader=U}async parseDependency(O){return await this.parseFile(O.url).then((I)=>O.ast=I).then((I)=>O.objectRegistry.collectAll(I))}async collectDependencies(O,I){return await this.collectProgramDependencies(O.ast).then((U)=>{U.forEach((_)=>{if(I.has(_.url))return;I.set(_.url,_)})})}async collectProgramDependencies(O){if(O===null)return new Map;let I=this.defaultDependencies();for(let _ of I.values())await this.parseDependency(_);let U=this.collectClassDependencies(O);for(let _ of U.values())await this.parseDependency(_),await this.collectDependencies(_,U);return new Map([...I,...U])}defaultDependencies(){let O=[new oI(["Iterator","Iterable"],"/library/contracts.lyra")],I=new Map;for(let U of O)I.set(U.url,U);return I}collectClassDependencies(O){let I=new Map;for(let U of O.children)if(U.type===z.IMPORT)if(U instanceof YO){if(U.from===null)continue;if(I.has(U.from))continue;I.set(U.from,new oI(U.names,U.from))}else X(`Invalid import node ${U.type}.`,U?.span);return I}parseFile(O){return this.fileLoader.load(O).then((I)=>this.parserSource(new F(I,O)))}parserSource(O){return new n(O).parse()}}var e_=new sO;class eI{environment;objectRegistry;dependencyLoader;constructor(O,I,U){this.environment=O,this.objectRegistry=I,this.dependencyLoader=new rI(O,I,U)}linkSources(O){return this.dependencyLoader.collectProgramDependencies(O).then((I)=>{for(let U of I.values()){let _=U.objectRegistry.fetchAllObjectDefinitions().values();for(let L of _){if(L instanceof QO)this.objectRegistry.interfaces.set(L.name,L);else this.objectRegistry.classes.set(L.name,L);this.environment.define(L.name,L)}}}).then(()=>this.loadNativeClasses(O))}loadNativeClasses(O){for(let I of O.children)if(I instanceof YO){if(I.from===null){let U=I.names[0];if(!U)hO(`Invalid import node ${I.type}.`,I?.span);let _=e_.registry.get(U)||null;if(!_)hO(`Unknown native class ${U}`,I?.span);let L=_.getClassDefinition();if(this.objectRegistry.classes.has(U))hO(`Could not resolve class ${U}.`,I?.span);this.objectRegistry.classes.set(U,L),this.environment.define(U,L)}}}}class OU{environment;objectRegistry;eventPipeline;constructor(O,I,U){this.environment=O,this.objectRegistry=I,this.eventPipeline=U}run(O){for(let I of O.children)if(I instanceof v)console.log(`\uD83E\uDDEA Running Test Cases for ${I.name} ...`),this.runTestCases(I)}runTestCases(O){for(let I of O.children)if(I instanceof T){let U=I.annotations?.find((_)=>_.name==="test");if(!U)continue;this.runTestCase(O,I,U)}}runTestCase(O,I,U){let _=d.fromAST(O).constructNewInstanceWithoutArguments(this.objectRegistry,this.environment,this.eventPipeline),W=NU(U).title??`${O.name}.${I.name}`,$=null;try{aO(_,I,[],this.objectRegistry,this.environment,this.eventPipeline)}catch(H){$=H}if($)console.error(`  ${W}, ${$}`);else console.log(`  ${W}`)}}class IU{environment;objectRegistry;eventPipeline;constructor(O,I,U){this.environment=O,this.objectRegistry=I,this.eventPipeline=U,VU(I,O),GU(O)}run(O){zO(O,this.objectRegistry,this.environment,this.eventPipeline)}}class tU{}class UU extends tU{load(O){return fetch(O).then((I)=>I.text())}}class a{listeners=new Map;on(O,I){if(!this.listeners.has(O))this.listeners.set(O,new Set);this.listeners.get(O).add(I)}off(O,I){this.listeners.get(O)?.delete(I)}emit(O,I){this.listeners.get(O)?.forEach((U)=>U(I))}}class rO{globalEnvironment=new x;globalObjectRegistry=new oO;globalEventPipeline;typeChecker=new pI(this.globalObjectRegistry);linker=new eI(this.globalEnvironment,this.globalObjectRegistry,new UU);interpreter;testSuite;isDebug=!1;startTime=0;constructor(O=!1,I=new a){this.isDebug=O,this.interpreter=new IU(this.globalEnvironment,this.globalObjectRegistry,I),this.testSuite=new OU(this.globalEnvironment,this.globalObjectRegistry,I),this.globalEventPipeline=I}getGlobalObjectRegistry(){return this.globalObjectRegistry}getGlobalEnvironment(){return this.globalEnvironment}getGlobalEventPipeline(){return this.globalEventPipeline}async execute(O){return this.runPipeline(O).then((I)=>{this.debugMeasureStartTime(),this.interpreter.run(I),this.debugMeasureEndTime("interpreter")})}async executeTest(O){return this.runPipeline(O).then((I)=>{this.debugMeasureStartTime(),this.testSuite.run(I),this.debugMeasureEndTime("test")})}debug(O){if(this.isDebug)console.log(O)}debugMeasureStartTime(){this.startTime=this.debugTimestamp()}debugMeasureEndTime(O){this.debug(O+": "+(this.debugTimestamp()-this.startTime)+"ms")}debugTimestamp(){if(!this.isDebug)return 0;return performance.now()}async runPipeline(O){this.debugMeasureStartTime();let I=new n(O).parse();return this.debugMeasureEndTime("parser"),this.debug(I),this.linker.linkSources(I).then(()=>{this.typeChecker.collectAllSymbolsFromRegistry(this.globalObjectRegistry)}).then(()=>{return this.debugMeasureStartTime(),this.typeChecker.check(I),this.debugMeasureEndTime("typechecker"),I})}}var OL=(O)=>{return O.toLowerCase().startsWith("on")},IL={DOM_EVENT:"dom:event",isEvent:OL},uO=IL;class gI{applicationRuntime;vdom;textBuffer=[];constructor(O,I){this.applicationRuntime=O;this.vdom=I}create(O){if(typeof O==="string")return document.createTextNode(O);if(O.isComponent&&O.component===null){O.component=this.applicationRuntime.createInstance(O.tag);for(let[W,$]of Object.entries(O.props))if(O.component.hasPublicProperty(W))O.component.setPublicProperty(W,$);let _=this.applicationRuntime.callMethod(O.component,"render",[]);this.vdom.register(O.component,_);let L=this.create(_);for(let[W,$]of Object.entries(O.props))L.setAttribute(W,String($));return O.dom=L,O.dom}let I=()=>{let _=this.flushTextBuffer();if(_)U.appendChild(_)},U=document.createElement(O.tag);O.dom=U;for(let[_,L]of Object.entries(O.props))if(uO.isEvent(_))this.applicationRuntime.addEventHandler(U,_,L);else U.setAttribute(_,String(L));for(let _ of O.children){if(typeof _==="string")this.textBuffer.push(_);else U.appendChild(this.create(_));I()}return I(),U}flushTextBuffer(){if(this.textBuffer.length===0)return null;let O=document.createTextNode(this.textBuffer.join(""));return this.textBuffer=[],O}}class _U{mountPoint;applicationRuntime;elementCreator;constructor(O,I,U,_=new gI(I,U)){this.mountPoint=O;this.applicationRuntime=I;this.elementCreator=_}patch(O,I){if(O){this.patchNode(this.mountPoint,O,I);return}let U=this.elementCreator.create(I);if(this.mountPoint.appendChild(U),typeof I!=="string")I.dom=U}patchNode(O,I,U){if(typeof I==="string"&&typeof U==="string"){if(I!==U){let L=O.firstChild;if(L)L.textContent=U}return}if(typeof I==="string"||typeof U==="string"){let L=this.elementCreator.create(U);if(O.replaceChild(L,O.firstChild),typeof U!=="string")U.dom=L;return}if(I.tag!==U.tag){let L=this.elementCreator.create(U);O.replaceChild(L,I.dom),U.dom=L;return}if(U.isComponent&&U.component===null){U.component=I.component;let L=this.elementCreator.create(this.applicationRuntime.renderComponent(I.component));O.replaceChild(L,I.dom),U.dom=L;return}let _=I.dom;U.dom=_,this.updateProperties(_,I.props,U.props),this.patchChildren(_,I.children,U.children)}updateProperties(O,I,U){for(let _ in I)if(!(_ in U))if(uO.isEvent(_))this.applicationRuntime.removeEventHandler(O,_);else O.removeAttribute(_);for(let _ in U){let L=I[_],W=U[_];if(L===W)continue;if(uO.isEvent(_)){if(L)this.applicationRuntime.removeEventHandler(O,_);this.applicationRuntime.addEventHandler(O,_,W)}else O.setAttribute(_,W)}}patchChildren(O,I,U){let _=Math.max(I.length,U.length);for(let L=0;L<_;L++){let W=I[L],$=U[L];if(!W&&$){O.appendChild(this.elementCreator.create($));continue}let H=O.childNodes[L];if(H){if(W&&!$){O.removeChild(H);continue}if($&&W)this.patchNode(H.parentNode,W,$)}}}}var UL=new SO().getClassDefinition();class uI{globalEventPipeline;program;globalObjectRegistry;globalEnvironment;rootInstance=null;constructor(O=new a,I=!1){this.globalEventPipeline=O;this.program=new rO(I,this.globalEventPipeline),this.globalObjectRegistry=this.program.getGlobalObjectRegistry(),this.globalEnvironment=this.program.getGlobalEnvironment()}getRootInstance(){if(this.rootInstance===null)throw Error("No root instance available.");return this.rootInstance}createInstance(O){return this.getClassDefinition(O).constructNewInstanceWithoutArguments(this.globalObjectRegistry,this.globalEnvironment,this.globalEventPipeline)}callRootInstanceMethod(O,I){return this.callInstanceMethod(this.getRootInstance(),O,I)}callInstanceMethod(O,I,U){return aO(O,O.findeMethodNode(I),U,this.globalObjectRegistry,this.globalEnvironment,this.globalEventPipeline)}async executeEntryFile(O,I){return this.program.execute(await kO(O)).then(()=>{this.rootInstance=this.createInstance(I)})}createEvent(O){return UL.constructNativeInstance(this.globalObjectRegistry,[O])}createEventHandler(O,I){return(U)=>{this.globalEventPipeline.emit(I,{invoke:()=>{let _=O.functionEnv.get(E.THIS);O.evalCall(_,this.createEvent(U))},event:U})}}getClassDefinition(O){return this.globalObjectRegistry.classes.get(O)}}class PI{registry=new WeakMap;register(O,I,U){let _=this.registry.get(O)??{};_[I]=U,this.registry.set(O,_)}unregister(O,I){let U=this.registry.get(O)??{},_=U[I];if(_)return delete U[I],this.registry.set(O,U),_;return null}}class LU{instanceMap=new Map;register(O,I){this.instanceMap.set(O.id,I)}getNodeByInstance(O){let I=this.instanceMap.get(O.id);if(!I)throw Error(`Instance with id ${O.id} not found.`);return I}}class aU{_engine;_eventPipeline;eventHandlerRegistry;constructor(O,I=new a,U=new PI){this._engine=O;this._eventPipeline=I;this.eventHandlerRegistry=U}get engine(){return this._engine}get eventPipeline(){return this._eventPipeline}renderRootComponent(){return this.renderComponent(this._engine.getRootInstance())}renderComponent(O){return this.callMethod(O,"render",[])}start(O,I){throw Error("Method not implemented.")}createInstance(O){return this._engine.createInstance(O)}callRootInstanceMethod(O,I=[]){return this._engine.callRootInstanceMethod(O,I)}callMethod(O,I,U=[]){return this._engine.callInstanceMethod(O,I,U)}addEventHandler(O,I,U){let _=I.slice(2).toLowerCase(),L=this.engine.createEventHandler(U,uO.DOM_EVENT);this.eventHandlerRegistry.register(O,I,L),O.addEventListener(_,L)}removeEventHandler(O,I){let U=I.slice(2).toLowerCase(),_=this.eventHandlerRegistry.unregister(O,I);if(_)O.removeEventListener(U,_)}}class pU extends aU{vdom=new LU;patcher;currentVNode=null;isRendering=!1;constructor(O,I=!1,U=new a,_=new PI){super(new uI(U,I),U,_);this.patcher=new _U(O,this,this.vdom)}async start(O,I="App"){await this.engine.executeEntryFile(O,I),this.listenToDomEvents(),this.requestFullRender()}requestFullRender(){if(this.isRendering)return;queueMicrotask(()=>{this.performFullRender()})}requestComponentRender(O,I){if(this.isRendering)return;queueMicrotask(()=>{this.performComponentRender(O,I)})}performFullRender(){this.isRendering=!0;let O=this.renderRootComponent();this.patcher.patch(this.currentVNode,O),this.currentVNode=O,this.vdom.register(this.engine.getRootInstance(),O),this.isRendering=!1}performComponentRender(O,I){this.isRendering=!0;let U=this.renderComponent(I);this.patcher.patch(O,U),this.vdom.register(I,U),this.isRendering=!1}listenToDomEvents(){this.eventPipeline.on(uO.DOM_EVENT,({invoke:O})=>{O()}),this.eventPipeline.on(pO.LYRA_INSTANCE_DIRTY_STATE,({instance:O})=>{this.requestComponentRender(this.vdom.getNodeByInstance(O),O)})}}var _L={Source:F,Parser:n,Tokenizer:GO,EventPipeline:a,HTMLElementCreator:gI,State:lO,Program:(O)=>eO(O),execute:(O,I=!1)=>oU(O,I),executeFromString:(O,I=!1)=>EL(O,I),executeFromUrl:async(O,I=!1)=>LL(O,I),executeTest:(O,I=!1)=>rU(O,I),executeTestString:(O,I=!1)=>$L(O,I),executeTestUrl:(O,I=!1)=>WL(O,I),tokenize:(O)=>eU(O),tokenizeUrl:(O)=>HL(O),parseTree:(O)=>O_(O),parseTreeUrl:(O)=>zL(O)};function eO(O=!1){return new rO(O)}async function oU(O,I=!1){try{return await eO(I).execute(O)}catch(U){if(U instanceof Error)console.error(iO(U,O).format());throw U}}async function LL(O,I=!1){return await oU(await kO(O),I)}async function EL(O,I=!1){let U=new F(O);try{return await eO(I).execute(U)}catch(_){if(_ instanceof Error)console.error(iO(_,U).format());throw _}}async function rU(O,I=!1){try{return await eO(I).executeTest(O)}catch(U){if(U instanceof Error)console.error(iO(U,O).format());throw U}}async function WL(O,I=!1){return await rU(await kO(O),I)}async function $L(O,I=!1){let U=new F(O);try{return await eO(I).executeTest(U)}catch(_){if(_ instanceof Error)console.error(iO(_,U).format());throw _}}function eU(O){return new GO(O).tokenize()}async function HL(O){return eU(await kO(O))}function O_(O){return new n(O).parse()}async function zL(O){return O_(await kO(O))}var UH=_L;export{HL as tokenizeUrl,eU as tokenize,zL as parseTreeUrl,O_ as parseTree,UH as default,uI as WebLyraScript,pU as WebApplicationRuntime};
